"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HandlebarsNodeVisitors = undefined;

var _builders = require("../builders");

var _builders2 = _interopRequireDefault(_builders);

var _utils = require("../utils");

var _parser = require("../parser");

var _syntaxError = require("../errors/syntax-error");

var _syntaxError2 = _interopRequireDefault(_syntaxError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);for (var i = 0; i < keys.length; i++) {
        var key = keys[i];var value = Object.getOwnPropertyDescriptor(defaults, key);if (value && value.configurable && obj[key] === undefined) {
            Object.defineProperty(obj, key, value);
        }
    }return obj;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
}

var HandlebarsNodeVisitors = exports.HandlebarsNodeVisitors = function (_Parser) {
    _inherits(HandlebarsNodeVisitors, _Parser);

    function HandlebarsNodeVisitors() {
        _classCallCheck(this, HandlebarsNodeVisitors);

        var _this = _possibleConstructorReturn(this, _Parser.apply(this, arguments));

        _this.cursorCount = 0;
        return _this;
    }

    HandlebarsNodeVisitors.prototype.cursor = function cursor() {
        return '%cursor:' + this.cursorCount++ + '%';
    };

    HandlebarsNodeVisitors.prototype.Program = function Program(program) {
        var body = [];
        this.cursorCount = 0;
        var node = _builders2.default.program(body, program.blockParams, program.loc);
        var i = void 0,
            l = program.body.length;
        this.elementStack.push(node);
        if (l === 0) {
            return this.elementStack.pop();
        }
        for (i = 0; i < l; i++) {
            this.acceptNode(program.body[i]);
        }
        // Ensure that that the element stack is balanced properly.
        var poppedNode = this.elementStack.pop();
        if (poppedNode !== node) {
            var elementNode = poppedNode;
            throw new _syntaxError2.default('Unclosed element `' + elementNode.tag + '` (on line ' + elementNode.loc.start.line + ').', elementNode.loc);
        }
        return node;
    };

    HandlebarsNodeVisitors.prototype.BlockStatement = function BlockStatement(block) {
        if (this.tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(block));
            return;
        }
        if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {
            throw new _syntaxError2.default('A block may only be used inside an HTML element or another block.', block.loc);
        }

        var _acceptCallNodes = acceptCallNodes(this, block),
            path = _acceptCallNodes.path,
            params = _acceptCallNodes.params,
            hash = _acceptCallNodes.hash;

        var program = this.Program(block.program);
        var inverse = block.inverse ? this.Program(block.inverse) : null;
        if (path.original === 'in-element') {
            hash = addInElementHash(this.cursor(), hash, block.loc);
        }
        var node = _builders2.default.block(path, params, hash, program, inverse, block.loc);
        var parentProgram = this.currentElement();
        (0, _utils.appendChild)(parentProgram, node);
    };

    HandlebarsNodeVisitors.prototype.MustacheStatement = function MustacheStatement(rawMustache) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawMustache));
            return;
        }
        var mustache = void 0;
        var escaped = rawMustache.escaped,
            loc = rawMustache.loc;

        if (rawMustache.path.type.match(/Literal$/)) {
            mustache = {
                type: 'MustacheStatement',
                path: this.acceptNode(rawMustache.path),
                params: [],
                hash: _builders2.default.hash(),
                escaped: escaped,
                loc: loc
            };
        } else {
            var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
                path = _acceptCallNodes2.path,
                params = _acceptCallNodes2.params,
                hash = _acceptCallNodes2.hash;

            mustache = _builders2.default.mustache(path, params, hash, !escaped, loc);
        }
        switch (tokenizer.state) {
            // Tag helpers
            case "tagOpen" /* tagOpen */:
            case "tagName" /* tagName */:
                throw new _syntaxError2.default('Cannot use mustaches in an elements tagname: `' + this.sourceForNode(rawMustache, rawMustache.path) + '` at L' + loc.start.line + ':C' + loc.start.column, mustache.loc);
            case "beforeAttributeName" /* beforeAttributeName */:
                addElementModifier(this.currentStartTag, mustache);
                break;
            case "attributeName" /* attributeName */:
            case "afterAttributeName" /* afterAttributeName */:
                this.beginAttributeValue(false);
                this.finishAttributeValue();
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            case "afterAttributeValueQuoted" /* afterAttributeValueQuoted */:
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            // Attribute values
            case "beforeAttributeValue" /* beforeAttributeValue */:
                this.beginAttributeValue(false);
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                tokenizer.transitionTo("attributeValueUnquoted" /* attributeValueUnquoted */);
                break;
            case "attributeValueDoubleQuoted" /* attributeValueDoubleQuoted */:
            case "attributeValueSingleQuoted" /* attributeValueSingleQuoted */:
            case "attributeValueUnquoted" /* attributeValueUnquoted */:
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                break;
            // TODO: Only append child when the tokenizer state makes
            // sense to do so, otherwise throw an error.
            default:
                (0, _utils.appendChild)(this.currentElement(), mustache);
        }
        return mustache;
    };

    HandlebarsNodeVisitors.prototype.ContentStatement = function ContentStatement(content) {
        updateTokenizerLocation(this.tokenizer, content);
        this.tokenizer.tokenizePart(content.value);
        this.tokenizer.flushData();
    };

    HandlebarsNodeVisitors.prototype.CommentStatement = function CommentStatement(rawComment) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === "comment" /* comment */) {
                this.appendToCommentData(this.sourceForNode(rawComment));
                return null;
            }
        var value = rawComment.value,
            loc = rawComment.loc;

        var comment = _builders2.default.mustacheComment(value, loc);
        switch (tokenizer.state) {
            case "beforeAttributeName" /* beforeAttributeName */:
                this.currentStartTag.comments.push(comment);
                break;
            case "beforeData" /* beforeData */:
            case "data" /* data */:
                (0, _utils.appendChild)(this.currentElement(), comment);
                break;
            default:
                throw new _syntaxError2.default('Using a Handlebars comment when in the `' + tokenizer['state'] + '` state is not supported: "' + comment.value + '" on line ' + loc.start.line + ':' + loc.start.column, rawComment.loc);
        }
        return comment;
    };

    HandlebarsNodeVisitors.prototype.PartialStatement = function PartialStatement(partial) {
        var loc = partial.loc;

        throw new _syntaxError2.default('Handlebars partials are not supported: "' + this.sourceForNode(partial, partial.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partial.loc);
    };

    HandlebarsNodeVisitors.prototype.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
        var loc = partialBlock.loc;

        throw new _syntaxError2.default('Handlebars partial blocks are not supported: "' + this.sourceForNode(partialBlock, partialBlock.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partialBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.Decorator = function Decorator(decorator) {
        var loc = decorator.loc;

        throw new _syntaxError2.default('Handlebars decorators are not supported: "' + this.sourceForNode(decorator, decorator.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decorator.loc);
    };

    HandlebarsNodeVisitors.prototype.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
        var loc = decoratorBlock.loc;

        throw new _syntaxError2.default('Handlebars decorator blocks are not supported: "' + this.sourceForNode(decoratorBlock, decoratorBlock.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decoratorBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.SubExpression = function SubExpression(sexpr) {
        var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
            path = _acceptCallNodes3.path,
            params = _acceptCallNodes3.params,
            hash = _acceptCallNodes3.hash;

        return _builders2.default.sexpr(path, params, hash, sexpr.loc);
    };

    HandlebarsNodeVisitors.prototype.PathExpression = function PathExpression(path) {
        var original = path.original,
            loc = path.loc;

        var parts = void 0;
        if (original.indexOf('/') !== -1) {
            if (original.slice(0, 2) === './') {
                throw new _syntaxError2.default('Using "./" is not supported in Glimmer and unnecessary: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.slice(0, 3) === '../') {
                throw new _syntaxError2.default('Changing context using "../" is not supported in Glimmer: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.indexOf('.') !== -1) {
                throw new _syntaxError2.default('Mixing \'.\' and \'/\' in paths is not supported in Glimmer; use only \'.\' to separate property paths: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            parts = [path.parts.join('/')];
        } else if (original === '.') {
            var locationInfo = 'L' + loc.start.line + ':C' + loc.start.column;
            throw new _syntaxError2.default('\'.\' is not a supported path in Glimmer; check for a path with a trailing \'.\' at ' + locationInfo + '.', path.loc);
        } else {
            parts = path.parts;
        }
        var thisHead = false;
        // This is to fix a bug in the Handlebars AST where the path expressions in
        // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
        // are simply turned into `{{foo}}`. The fix is to push it back onto the
        // parts array and let the runtime see the difference. However, we cannot
        // simply use the string `this` as it means literally the property called
        // "this" in the current context (it can be expressed in the syntax as
        // `{{[this]}}`, where the square bracket are generally for this kind of
        // escaping – such as `{{foo.["bar.baz"]}}` would mean lookup a property
        // named literally "bar.baz" on `this.foo`). By convention, we use `null`
        // for this purpose.
        if (original.match(/^this(\..+)?$/)) {
            thisHead = true;
        }
        return {
            type: 'PathExpression',
            original: path.original,
            this: thisHead,
            parts: parts,
            data: path.data,
            loc: path.loc
        };
    };

    HandlebarsNodeVisitors.prototype.Hash = function Hash(hash) {
        var pairs = [];
        for (var i = 0; i < hash.pairs.length; i++) {
            var pair = hash.pairs[i];
            pairs.push(_builders2.default.pair(pair.key, this.acceptNode(pair.value), pair.loc));
        }
        return _builders2.default.hash(pairs, hash.loc);
    };

    HandlebarsNodeVisitors.prototype.StringLiteral = function StringLiteral(string) {
        return _builders2.default.literal('StringLiteral', string.value, string.loc);
    };

    HandlebarsNodeVisitors.prototype.BooleanLiteral = function BooleanLiteral(boolean) {
        return _builders2.default.literal('BooleanLiteral', boolean.value, boolean.loc);
    };

    HandlebarsNodeVisitors.prototype.NumberLiteral = function NumberLiteral(number) {
        return _builders2.default.literal('NumberLiteral', number.value, number.loc);
    };

    HandlebarsNodeVisitors.prototype.UndefinedLiteral = function UndefinedLiteral(undef) {
        return _builders2.default.literal('UndefinedLiteral', undefined, undef.loc);
    };

    HandlebarsNodeVisitors.prototype.NullLiteral = function NullLiteral(nul) {
        return _builders2.default.literal('NullLiteral', null, nul.loc);
    };

    return HandlebarsNodeVisitors;
}(_parser.Parser);
function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
        // if it is empty, just return the count of newlines
        // in original
        return {
            lines: original.split('\n').length - 1,
            columns: 0
        };
    }
    // otherwise, return the number of newlines prior to
    // `value`
    var difference = original.split(value)[0];
    var lines = difference.split(/\n/);
    var lineCount = lines.length - 1;
    return {
        lines: lineCount,
        columns: lines[lineCount].length
    };
}
function updateTokenizerLocation(tokenizer, content) {
    var line = content.loc.start.line;
    var column = content.loc.start.column;
    var offsets = calculateRightStrippedOffsets(content.original, content.value);
    line = line + offsets.lines;
    if (offsets.lines) {
        column = offsets.columns;
    } else {
        column = column + offsets.columns;
    }
    tokenizer.line = line;
    tokenizer.column = column;
}
function acceptCallNodes(compiler, node) {
    var path = compiler.PathExpression(node.path);
    var params = node.params ? node.params.map(function (e) {
        return compiler.acceptNode(e);
    }) : [];
    var hash = node.hash ? compiler.Hash(node.hash) : _builders2.default.hash();
    return { path: path, params: params, hash: hash };
}
function addElementModifier(element, mustache) {
    var path = mustache.path,
        params = mustache.params,
        hash = mustache.hash,
        loc = mustache.loc;

    if ((0, _utils.isLiteral)(path)) {
        var _modifier = '{{' + (0, _utils.printLiteral)(path) + '}}';
        var tag = '<' + element.name + ' ... ' + _modifier + ' ...';
        throw new _syntaxError2.default('In ' + tag + ', ' + _modifier + ' is not a valid modifier: "' + path.original + '" on line ' + (loc && loc.start.line) + '.', mustache.loc);
    }
    var modifier = _builders2.default.elementModifier(path, params, hash, loc);
    element.modifiers.push(modifier);
}
function addInElementHash(cursor, hash, loc) {
    var hasNextSibling = false;
    hash.pairs.forEach(function (pair) {
        if (pair.key === 'guid') {
            throw new _syntaxError2.default('Cannot pass `guid` from user space', loc);
        }
        if (pair.key === 'nextSibling') {
            hasNextSibling = true;
        }
    });
    var guid = _builders2.default.literal('StringLiteral', cursor);
    var guidPair = _builders2.default.pair('guid', guid);
    hash.pairs.unshift(guidPair);
    if (!hasNextSibling) {
        var nullLiteral = _builders2.default.literal('NullLiteral', null);
        var nextSibling = _builders2.default.pair('nextSibling', nullLiteral);
        hash.pairs.push(nextSibling);
    }
    return hash;
}
function appendDynamicAttributeValuePart(attribute, part) {
    attribute.isDynamic = true;
    attribute.parts.push(part);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9wYXJzZXIvaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxBQUFPLEFBQUMsQUFBTSxBQUFhLEFBQUM7Ozs7QUFDNUIsQUFBTyxBQUFFLEFBQVcsQUFBRSxBQUFTLEFBQUUsQUFBWSxBQUFFLEFBQU0sQUFBVSxBQUFDOztBQUdoRSxBQUFPLEFBQUUsQUFBTSxBQUFrQixBQUFNLEFBQVcsQUFBQzs7QUFDbkQsQUFBTyxBQUFXLEFBQU0sQUFBd0IsQUFBQyxBQUtqRCxBQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUF1Qzs7Ozs7O3lFQUszQzs7Y0FBVyxjQUFHLEFBQUMsQUFBQyxBQWtWbEIsQUFBQztlQWhWQyxBQUFNOzs7Z0VBQ0osQUFBTzs0QkFBVyxBQUFJLEtBQUMsQUFBVyxBQUFFLEFBQUcsQUFBQyxBQUMxQyxBQUFDLGdCQUVELEFBQU87OztnRUFBQyxBQUE4QixTQUNwQztZQUFJLEFBQUksT0FBb0IsQUFBRSxBQUFDLEFBQy9CLEFBQUk7YUFBQyxBQUFXLGNBQUcsQUFBQyxBQUFDLEFBQ3JCO1lBQUksQUFBSSxPQUFHLEFBQUMsbUJBQUMsQUFBTyxRQUFDLEFBQUksTUFBRSxBQUFPLFFBQUMsQUFBVyxhQUFFLEFBQU8sUUFBQyxBQUFHLEFBQUMsQUFBQyxBQUM3RDtZQUFJLEFBQUM7WUFDSCxBQUFDLElBQUcsQUFBTyxRQUFDLEFBQUksS0FBQyxBQUFNLEFBQUMsQUFFMUIsQUFBSTthQUFDLEFBQVksYUFBQyxBQUFJLEtBQUMsQUFBSSxBQUFDLEFBQUMsQUFFN0I7WUFBSSxBQUFDLE1BQUssQUFBQyxHQUFFLEFBQ1g7bUJBQU8sQUFBSSxLQUFDLEFBQVksYUFBQyxBQUFHLEFBQWlCLEFB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InNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCB7IGFwcGVuZENoaWxkLCBpc0xpdGVyYWwsIHByaW50TGl0ZXJhbCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5pbXBvcnQgKiBhcyBIYW5kbGViYXJzQVNUIGZyb20gJy4uL3R5cGVzL2hhbmRsZWJhcnMtYXN0JztcbmltcG9ydCB7IFBhcnNlciwgVGFnLCBBdHRyaWJ1dGUgfSBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IFN5bnRheEVycm9yIGZyb20gJy4uL2Vycm9ycy9zeW50YXgtZXJyb3InO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBSZWNhc3QgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFRva2VuaXplclN0YXRlIH0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMgZXh0ZW5kcyBQYXJzZXIge1xuICBhYnN0cmFjdCBhcHBlbmRUb0NvbW1lbnREYXRhKHM6IHN0cmluZyk6IHZvaWQ7XG4gIGFic3RyYWN0IGJlZ2luQXR0cmlidXRlVmFsdWUocXVvdGVkOiBib29sZWFuKTogdm9pZDtcbiAgYWJzdHJhY3QgZmluaXNoQXR0cmlidXRlVmFsdWUoKTogdm9pZDtcblxuICBjdXJzb3JDb3VudCA9IDA7XG5cbiAgY3Vyc29yKCkge1xuICAgIHJldHVybiBgJWN1cnNvcjoke3RoaXMuY3Vyc29yQ291bnQrK30lYDtcbiAgfVxuXG4gIFByb2dyYW0ocHJvZ3JhbTogSGFuZGxlYmFyc0FTVC5Qcm9ncmFtKTogQVNULlByb2dyYW0ge1xuICAgIGxldCBib2R5OiBBU1QuU3RhdGVtZW50W10gPSBbXTtcbiAgICB0aGlzLmN1cnNvckNvdW50ID0gMDtcbiAgICBsZXQgbm9kZSA9IGIucHJvZ3JhbShib2R5LCBwcm9ncmFtLmJsb2NrUGFyYW1zLCBwcm9ncmFtLmxvYyk7XG4gICAgbGV0IGksXG4gICAgICBsID0gcHJvZ3JhbS5ib2R5Lmxlbmd0aDtcblxuICAgIHRoaXMuZWxlbWVudFN0YWNrLnB1c2gobm9kZSk7XG5cbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpIGFzIEFTVC5Qcm9ncmFtO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuYWNjZXB0Tm9kZShwcm9ncmFtLmJvZHlbaV0pO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoYXQgdGhlIGVsZW1lbnQgc3RhY2sgaXMgYmFsYW5jZWQgcHJvcGVybHkuXG4gICAgbGV0IHBvcHBlZE5vZGUgPSB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKTtcbiAgICBpZiAocG9wcGVkTm9kZSAhPT0gbm9kZSkge1xuICAgICAgbGV0IGVsZW1lbnROb2RlID0gcG9wcGVkTm9kZSBhcyBBU1QuRWxlbWVudE5vZGU7XG5cbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgJ1VuY2xvc2VkIGVsZW1lbnQgYCcgKyBlbGVtZW50Tm9kZS50YWcgKyAnYCAob24gbGluZSAnICsgZWxlbWVudE5vZGUubG9jIS5zdGFydC5saW5lICsgJykuJyxcbiAgICAgICAgZWxlbWVudE5vZGUubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgQmxvY2tTdGF0ZW1lbnQoYmxvY2s6IEhhbmRsZWJhcnNBU1QuQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICBpZiAodGhpcy50b2tlbml6ZXJbJ3N0YXRlJ10gPT09ICdjb21tZW50Jykge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShibG9jaykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMudG9rZW5pemVyWydzdGF0ZSddICE9PSAnY29tbWVudCcgJiZcbiAgICAgIHRoaXMudG9rZW5pemVyWydzdGF0ZSddICE9PSAnZGF0YScgJiZcbiAgICAgIHRoaXMudG9rZW5pemVyWydzdGF0ZSddICE9PSAnYmVmb3JlRGF0YSdcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgJ0EgYmxvY2sgbWF5IG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gSFRNTCBlbGVtZW50IG9yIGFub3RoZXIgYmxvY2suJyxcbiAgICAgICAgYmxvY2subG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIGJsb2NrKTtcbiAgICBsZXQgcHJvZ3JhbSA9IHRoaXMuUHJvZ3JhbShibG9jay5wcm9ncmFtKTtcbiAgICBsZXQgaW52ZXJzZSA9IGJsb2NrLmludmVyc2UgPyB0aGlzLlByb2dyYW0oYmxvY2suaW52ZXJzZSkgOiBudWxsO1xuXG4gICAgaWYgKHBhdGgub3JpZ2luYWwgPT09ICdpbi1lbGVtZW50Jykge1xuICAgICAgaGFzaCA9IGFkZEluRWxlbWVudEhhc2godGhpcy5jdXJzb3IoKSwgaGFzaCwgYmxvY2subG9jKTtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IGIuYmxvY2socGF0aCwgcGFyYW1zLCBoYXNoLCBwcm9ncmFtLCBpbnZlcnNlLCBibG9jay5sb2MpO1xuXG4gICAgbGV0IHBhcmVudFByb2dyYW0gPSB0aGlzLmN1cnJlbnRFbGVtZW50KCk7XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50UHJvZ3JhbSwgbm9kZSk7XG4gIH1cblxuICBNdXN0YWNoZVN0YXRlbWVudChyYXdNdXN0YWNoZTogSGFuZGxlYmFyc0FTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICAgIGxldCB7IHRva2VuaXplciB9ID0gdGhpcztcblxuICAgIGlmICh0b2tlbml6ZXIuc3RhdGUgPT09ICdjb21tZW50Jykge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShyYXdNdXN0YWNoZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBtdXN0YWNoZTogQVNULk11c3RhY2hlU3RhdGVtZW50O1xuICAgIGxldCB7IGVzY2FwZWQsIGxvYyB9ID0gcmF3TXVzdGFjaGU7XG5cbiAgICBpZiAocmF3TXVzdGFjaGUucGF0aC50eXBlLm1hdGNoKC9MaXRlcmFsJC8pKSB7XG4gICAgICBtdXN0YWNoZSA9IHtcbiAgICAgICAgdHlwZTogJ011c3RhY2hlU3RhdGVtZW50JyxcbiAgICAgICAgcGF0aDogdGhpcy5hY2NlcHROb2RlPEFTVC5MaXRlcmFsPihyYXdNdXN0YWNoZS5wYXRoKSxcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgaGFzaDogYi5oYXNoKCksXG4gICAgICAgIGVzY2FwZWQsXG4gICAgICAgIGxvYyxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKFxuICAgICAgICB0aGlzLFxuICAgICAgICByYXdNdXN0YWNoZSBhcyBIYW5kbGViYXJzQVNULk11c3RhY2hlU3RhdGVtZW50ICYge1xuICAgICAgICAgIHBhdGg6IEhhbmRsZWJhcnNBU1QuUGF0aEV4cHJlc3Npb247XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBtdXN0YWNoZSA9IGIubXVzdGFjaGUocGF0aCwgcGFyYW1zLCBoYXNoLCAhZXNjYXBlZCwgbG9jKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuaXplci5zdGF0ZSkge1xuICAgICAgLy8gVGFnIGhlbHBlcnNcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUudGFnT3BlbjpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUudGFnTmFtZTpcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgdXNlIG11c3RhY2hlcyBpbiBhbiBlbGVtZW50cyB0YWduYW1lOiBcXGAke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgICAgIHJhd011c3RhY2hlLFxuICAgICAgICAgICAgcmF3TXVzdGFjaGUucGF0aFxuICAgICAgICAgICl9XFxgIGF0IEwke2xvYy5zdGFydC5saW5lfTpDJHtsb2Muc3RhcnQuY29sdW1ufWAsXG4gICAgICAgICAgbXVzdGFjaGUubG9jXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZTpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVOYW1lOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hZnRlckF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIHRoaXMuZmluaXNoQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hZnRlckF0dHJpYnV0ZVZhbHVlUXVvdGVkOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIEF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlVmFsdWU6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQodGhpcy5jdXJyZW50QXR0cmlidXRlISwgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlVW5xdW90ZWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZWQ6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVkOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVVucXVvdGVkOlxuICAgICAgICBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KHRoaXMuY3VycmVudEF0dHJpYnV0ZSEsIG11c3RhY2hlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFRPRE86IE9ubHkgYXBwZW5kIGNoaWxkIHdoZW4gdGhlIHRva2VuaXplciBzdGF0ZSBtYWtlc1xuICAgICAgLy8gc2Vuc2UgdG8gZG8gc28sIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgbXVzdGFjaGUpO1xuICAgIH1cblxuICAgIHJldHVybiBtdXN0YWNoZTtcbiAgfVxuXG4gIENvbnRlbnRTdGF0ZW1lbnQoY29udGVudDogSGFuZGxlYmFyc0FTVC5Db250ZW50U3RhdGVtZW50KSB7XG4gICAgdXBkYXRlVG9rZW5pemVyTG9jYXRpb24odGhpcy50b2tlbml6ZXIsIGNvbnRlbnQpO1xuXG4gICAgdGhpcy50b2tlbml6ZXIudG9rZW5pemVQYXJ0KGNvbnRlbnQudmFsdWUpO1xuICAgIHRoaXMudG9rZW5pemVyLmZsdXNoRGF0YSgpO1xuICB9XG5cbiAgQ29tbWVudFN0YXRlbWVudChcbiAgICByYXdDb21tZW50OiBIYW5kbGViYXJzQVNULkNvbW1lbnRTdGF0ZW1lbnRcbiAgKTogT3B0aW9uPEFTVC5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQ+IHtcbiAgICBsZXQgeyB0b2tlbml6ZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAodG9rZW5pemVyLnN0YXRlID09PSBUb2tlbml6ZXJTdGF0ZS5jb21tZW50KSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd0NvbW1lbnQpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCB7IHZhbHVlLCBsb2MgfSA9IHJhd0NvbW1lbnQ7XG4gICAgbGV0IGNvbW1lbnQgPSBiLm11c3RhY2hlQ29tbWVudCh2YWx1ZSwgbG9jKTtcblxuICAgIHN3aXRjaCAodG9rZW5pemVyLnN0YXRlKSB7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXJ0VGFnLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZURhdGE6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmRhdGE6XG4gICAgICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgY29tbWVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVzaW5nIGEgSGFuZGxlYmFycyBjb21tZW50IHdoZW4gaW4gdGhlIFxcYCR7XG4gICAgICAgICAgICB0b2tlbml6ZXJbJ3N0YXRlJ11cbiAgICAgICAgICB9XFxgIHN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQ6IFwiJHtjb21tZW50LnZhbHVlfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX06JHtcbiAgICAgICAgICAgIGxvYy5zdGFydC5jb2x1bW5cbiAgICAgICAgICB9YCxcbiAgICAgICAgICByYXdDb21tZW50LmxvY1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50O1xuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsOiBIYW5kbGViYXJzQVNULlBhcnRpYWxTdGF0ZW1lbnQpIHtcbiAgICBsZXQgeyBsb2MgfSA9IHBhcnRpYWw7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFscyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShwYXJ0aWFsLCBwYXJ0aWFsLm5hbWUpfVwiIGF0IEwke1xuICAgICAgICBsb2Muc3RhcnQubGluZVxuICAgICAgfTpDJHtsb2Muc3RhcnQuY29sdW1ufWAsXG4gICAgICBwYXJ0aWFsLmxvY1xuICAgICk7XG4gIH1cblxuICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQocGFydGlhbEJsb2NrOiBIYW5kbGViYXJzQVNULlBhcnRpYWxCbG9ja1N0YXRlbWVudCkge1xuICAgIGxldCB7IGxvYyB9ID0gcGFydGlhbEJsb2NrO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgcGFydGlhbCBibG9ja3MgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgIHBhcnRpYWxCbG9jayxcbiAgICAgICAgcGFydGlhbEJsb2NrLm5hbWVcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIHBhcnRpYWxCbG9jay5sb2NcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yKGRlY29yYXRvcjogSGFuZGxlYmFyc0FTVC5EZWNvcmF0b3IpIHtcbiAgICBsZXQgeyBsb2MgfSA9IGRlY29yYXRvcjtcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIGRlY29yYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgIGRlY29yYXRvcixcbiAgICAgICAgZGVjb3JhdG9yLnBhdGhcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIGRlY29yYXRvci5sb2NcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yQmxvY2soZGVjb3JhdG9yQmxvY2s6IEhhbmRsZWJhcnNBU1QuRGVjb3JhdG9yQmxvY2spIHtcbiAgICBsZXQgeyBsb2MgfSA9IGRlY29yYXRvckJsb2NrO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgZGVjb3JhdG9yIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgZGVjb3JhdG9yQmxvY2ssXG4gICAgICAgIGRlY29yYXRvckJsb2NrLnBhdGhcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIGRlY29yYXRvckJsb2NrLmxvY1xuICAgICk7XG4gIH1cblxuICBTdWJFeHByZXNzaW9uKHNleHByOiBIYW5kbGViYXJzQVNULlN1YkV4cHJlc3Npb24pOiBBU1QuU3ViRXhwcmVzc2lvbiB7XG4gICAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoIH0gPSBhY2NlcHRDYWxsTm9kZXModGhpcywgc2V4cHIpO1xuICAgIHJldHVybiBiLnNleHByKHBhdGgsIHBhcmFtcywgaGFzaCwgc2V4cHIubG9jKTtcbiAgfVxuXG4gIFBhdGhFeHByZXNzaW9uKHBhdGg6IEhhbmRsZWJhcnNBU1QuUGF0aEV4cHJlc3Npb24pOiBBU1QuUGF0aEV4cHJlc3Npb24ge1xuICAgIGxldCB7IG9yaWdpbmFsLCBsb2MgfSA9IHBhdGg7XG4gICAgbGV0IHBhcnRzOiBzdHJpbmdbXTtcblxuICAgIGlmIChvcmlnaW5hbC5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICBpZiAob3JpZ2luYWwuc2xpY2UoMCwgMikgPT09ICcuLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBVc2luZyBcIi4vXCIgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyIGFuZCB1bm5lY2Vzc2FyeTogXCIke3BhdGgub3JpZ2luYWx9XCIgb24gbGluZSAke1xuICAgICAgICAgICAgbG9jLnN0YXJ0LmxpbmVcbiAgICAgICAgICB9LmAsXG4gICAgICAgICAgcGF0aC5sb2NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnaW5hbC5zbGljZSgwLCAzKSA9PT0gJy4uLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBDaGFuZ2luZyBjb250ZXh0IHVzaW5nIFwiLi4vXCIgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOiBcIiR7cGF0aC5vcmlnaW5hbH1cIiBvbiBsaW5lICR7XG4gICAgICAgICAgICBsb2Muc3RhcnQubGluZVxuICAgICAgICAgIH0uYCxcbiAgICAgICAgICBwYXRoLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBNaXhpbmcgJy4nIGFuZCAnLycgaW4gcGF0aHMgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOyB1c2Ugb25seSAnLicgdG8gc2VwYXJhdGUgcHJvcGVydHkgcGF0aHM6IFwiJHtcbiAgICAgICAgICAgIHBhdGgub3JpZ2luYWxcbiAgICAgICAgICB9XCIgb24gbGluZSAke2xvYy5zdGFydC5saW5lfS5gLFxuICAgICAgICAgIHBhdGgubG9jXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwYXJ0cyA9IFtwYXRoLnBhcnRzLmpvaW4oJy8nKV07XG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbCA9PT0gJy4nKSB7XG4gICAgICBsZXQgbG9jYXRpb25JbmZvID0gYEwke2xvYy5zdGFydC5saW5lfTpDJHtsb2Muc3RhcnQuY29sdW1ufWA7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIGAnLicgaXMgbm90IGEgc3VwcG9ydGVkIHBhdGggaW4gR2xpbW1lcjsgY2hlY2sgZm9yIGEgcGF0aCB3aXRoIGEgdHJhaWxpbmcgJy4nIGF0ICR7bG9jYXRpb25JbmZvfS5gLFxuICAgICAgICBwYXRoLmxvY1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMgPSBwYXRoLnBhcnRzO1xuICAgIH1cblxuICAgIGxldCB0aGlzSGVhZCA9IGZhbHNlO1xuXG4gICAgLy8gVGhpcyBpcyB0byBmaXggYSBidWcgaW4gdGhlIEhhbmRsZWJhcnMgQVNUIHdoZXJlIHRoZSBwYXRoIGV4cHJlc3Npb25zIGluXG4gICAgLy8gYHt7dGhpcy5mb299fWAgKGFuZCBzaW1pbGFybHkgYHt7Zm9vLWJhciB0aGlzLmZvbyBuYW1lZD10aGlzLmZvb319YCBldGMpXG4gICAgLy8gYXJlIHNpbXBseSB0dXJuZWQgaW50byBge3tmb299fWAuIFRoZSBmaXggaXMgdG8gcHVzaCBpdCBiYWNrIG9udG8gdGhlXG4gICAgLy8gcGFydHMgYXJyYXkgYW5kIGxldCB0aGUgcnVudGltZSBzZWUgdGhlIGRpZmZlcmVuY2UuIEhvd2V2ZXIsIHdlIGNhbm5vdFxuICAgIC8vIHNpbXBseSB1c2UgdGhlIHN0cmluZyBgdGhpc2AgYXMgaXQgbWVhbnMgbGl0ZXJhbGx5IHRoZSBwcm9wZXJ0eSBjYWxsZWRcbiAgICAvLyBcInRoaXNcIiBpbiB0aGUgY3VycmVudCBjb250ZXh0IChpdCBjYW4gYmUgZXhwcmVzc2VkIGluIHRoZSBzeW50YXggYXNcbiAgICAvLyBge3tbdGhpc119fWAsIHdoZXJlIHRoZSBzcXVhcmUgYnJhY2tldCBhcmUgZ2VuZXJhbGx5IGZvciB0aGlzIGtpbmQgb2ZcbiAgICAvLyBlc2NhcGluZyDigJMgc3VjaCBhcyBge3tmb28uW1wiYmFyLmJhelwiXX19YCB3b3VsZCBtZWFuIGxvb2t1cCBhIHByb3BlcnR5XG4gICAgLy8gbmFtZWQgbGl0ZXJhbGx5IFwiYmFyLmJhelwiIG9uIGB0aGlzLmZvb2ApLiBCeSBjb252ZW50aW9uLCB3ZSB1c2UgYG51bGxgXG4gICAgLy8gZm9yIHRoaXMgcHVycG9zZS5cbiAgICBpZiAob3JpZ2luYWwubWF0Y2goL150aGlzKFxcLi4rKT8kLykpIHtcbiAgICAgIHRoaXNIZWFkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1BhdGhFeHByZXNzaW9uJyxcbiAgICAgIG9yaWdpbmFsOiBwYXRoLm9yaWdpbmFsLFxuICAgICAgdGhpczogdGhpc0hlYWQsXG4gICAgICBwYXJ0cyxcbiAgICAgIGRhdGE6IHBhdGguZGF0YSxcbiAgICAgIGxvYzogcGF0aC5sb2MsXG4gICAgfTtcbiAgfVxuXG4gIEhhc2goaGFzaDogSGFuZGxlYmFyc0FTVC5IYXNoKTogQVNULkhhc2gge1xuICAgIGxldCBwYWlyczogQVNULkhhc2hQYWlyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaC5wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhaXIgPSBoYXNoLnBhaXJzW2ldO1xuICAgICAgcGFpcnMucHVzaChiLnBhaXIocGFpci5rZXksIHRoaXMuYWNjZXB0Tm9kZTxBU1QuRXhwcmVzc2lvbj4ocGFpci52YWx1ZSksIHBhaXIubG9jKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuaGFzaChwYWlycywgaGFzaC5sb2MpO1xuICB9XG5cbiAgU3RyaW5nTGl0ZXJhbChzdHJpbmc6IEhhbmRsZWJhcnNBU1QuU3RyaW5nTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnLCBzdHJpbmcudmFsdWUsIHN0cmluZy5sb2MpO1xuICB9XG5cbiAgQm9vbGVhbkxpdGVyYWwoYm9vbGVhbjogSGFuZGxlYmFyc0FTVC5Cb29sZWFuTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ0Jvb2xlYW5MaXRlcmFsJywgYm9vbGVhbi52YWx1ZSwgYm9vbGVhbi5sb2MpO1xuICB9XG5cbiAgTnVtYmVyTGl0ZXJhbChudW1iZXI6IEhhbmRsZWJhcnNBU1QuTnVtYmVyTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bWJlckxpdGVyYWwnLCBudW1iZXIudmFsdWUsIG51bWJlci5sb2MpO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbCh1bmRlZjogSGFuZGxlYmFyc0FTVC5VbmRlZmluZWRMaXRlcmFsKSB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCwgdW5kZWYubG9jKTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKG51bDogSGFuZGxlYmFyc0FTVC5OdWxsTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bGxMaXRlcmFsJywgbnVsbCwgbnVsLmxvYyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMob3JpZ2luYWw6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgLy8gaWYgaXQgaXMgZW1wdHksIGp1c3QgcmV0dXJuIHRoZSBjb3VudCBvZiBuZXdsaW5lc1xuICAgIC8vIGluIG9yaWdpbmFsXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVzOiBvcmlnaW5hbC5zcGxpdCgnXFxuJykubGVuZ3RoIC0gMSxcbiAgICAgIGNvbHVtbnM6IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgbmV3bGluZXMgcHJpb3IgdG9cbiAgLy8gYHZhbHVlYFxuICBsZXQgZGlmZmVyZW5jZSA9IG9yaWdpbmFsLnNwbGl0KHZhbHVlKVswXTtcbiAgbGV0IGxpbmVzID0gZGlmZmVyZW5jZS5zcGxpdCgvXFxuLyk7XG4gIGxldCBsaW5lQ291bnQgPSBsaW5lcy5sZW5ndGggLSAxO1xuXG4gIHJldHVybiB7XG4gICAgbGluZXM6IGxpbmVDb3VudCxcbiAgICBjb2x1bW5zOiBsaW5lc1tsaW5lQ291bnRdLmxlbmd0aCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVG9rZW5pemVyTG9jYXRpb24oXG4gIHRva2VuaXplcjogUGFyc2VyWyd0b2tlbml6ZXInXSxcbiAgY29udGVudDogSGFuZGxlYmFyc0FTVC5Db250ZW50U3RhdGVtZW50XG4pIHtcbiAgbGV0IGxpbmUgPSBjb250ZW50LmxvYy5zdGFydC5saW5lO1xuICBsZXQgY29sdW1uID0gY29udGVudC5sb2Muc3RhcnQuY29sdW1uO1xuXG4gIGxldCBvZmZzZXRzID0gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMoXG4gICAgY29udGVudC5vcmlnaW5hbCBhcyBSZWNhc3Q8SGFuZGxlYmFyc0FTVC5TdHJpcEZsYWdzLCBzdHJpbmc+LFxuICAgIGNvbnRlbnQudmFsdWVcbiAgKTtcblxuICBsaW5lID0gbGluZSArIG9mZnNldHMubGluZXM7XG4gIGlmIChvZmZzZXRzLmxpbmVzKSB7XG4gICAgY29sdW1uID0gb2Zmc2V0cy5jb2x1bW5zO1xuICB9IGVsc2Uge1xuICAgIGNvbHVtbiA9IGNvbHVtbiArIG9mZnNldHMuY29sdW1ucztcbiAgfVxuXG4gIHRva2VuaXplci5saW5lID0gbGluZTtcbiAgdG9rZW5pemVyLmNvbHVtbiA9IGNvbHVtbjtcbn1cblxuZnVuY3Rpb24gYWNjZXB0Q2FsbE5vZGVzKFxuICBjb21waWxlcjogSGFuZGxlYmFyc05vZGVWaXNpdG9ycyxcbiAgbm9kZToge1xuICAgIHBhdGg6IEhhbmRsZWJhcnNBU1QuUGF0aEV4cHJlc3Npb247XG4gICAgcGFyYW1zOiBIYW5kbGViYXJzQVNULkV4cHJlc3Npb25bXTtcbiAgICBoYXNoOiBIYW5kbGViYXJzQVNULkhhc2g7XG4gIH1cbik6IHsgcGF0aDogQVNULlBhdGhFeHByZXNzaW9uOyBwYXJhbXM6IEFTVC5FeHByZXNzaW9uW107IGhhc2g6IEFTVC5IYXNoIH0ge1xuICBsZXQgcGF0aCA9IGNvbXBpbGVyLlBhdGhFeHByZXNzaW9uKG5vZGUucGF0aCk7XG5cbiAgbGV0IHBhcmFtcyA9IG5vZGUucGFyYW1zID8gbm9kZS5wYXJhbXMubWFwKGUgPT4gY29tcGlsZXIuYWNjZXB0Tm9kZTxBU1QuRXhwcmVzc2lvbj4oZSkpIDogW107XG4gIGxldCBoYXNoID0gbm9kZS5oYXNoID8gY29tcGlsZXIuSGFzaChub2RlLmhhc2gpIDogYi5oYXNoKCk7XG5cbiAgcmV0dXJuIHsgcGF0aCwgcGFyYW1zLCBoYXNoIH07XG59XG5cbmZ1bmN0aW9uIGFkZEVsZW1lbnRNb2RpZmllcihlbGVtZW50OiBUYWc8J1N0YXJ0VGFnJz4sIG11c3RhY2hlOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoLCBsb2MgfSA9IG11c3RhY2hlO1xuXG4gIGlmIChpc0xpdGVyYWwocGF0aCkpIHtcbiAgICBsZXQgbW9kaWZpZXIgPSBge3ske3ByaW50TGl0ZXJhbChwYXRoKX19fWA7XG4gICAgbGV0IHRhZyA9IGA8JHtlbGVtZW50Lm5hbWV9IC4uLiAke21vZGlmaWVyfSAuLi5gO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEluICR7dGFnfSwgJHttb2RpZmllcn0gaXMgbm90IGEgdmFsaWQgbW9kaWZpZXI6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2MgJiZcbiAgICAgICAgbG9jLnN0YXJ0LmxpbmV9LmAsXG4gICAgICBtdXN0YWNoZS5sb2NcbiAgICApO1xuICB9XG5cbiAgbGV0IG1vZGlmaWVyID0gYi5lbGVtZW50TW9kaWZpZXIocGF0aCwgcGFyYW1zLCBoYXNoLCBsb2MpO1xuICBlbGVtZW50Lm1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbn1cblxuZnVuY3Rpb24gYWRkSW5FbGVtZW50SGFzaChjdXJzb3I6IHN0cmluZywgaGFzaDogQVNULkhhc2gsIGxvYzogQVNULlNvdXJjZUxvY2F0aW9uKSB7XG4gIGxldCBoYXNOZXh0U2libGluZyA9IGZhbHNlO1xuICBoYXNoLnBhaXJzLmZvckVhY2gocGFpciA9PiB7XG4gICAgaWYgKHBhaXIua2V5ID09PSAnZ3VpZCcpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ2Fubm90IHBhc3MgYGd1aWRgIGZyb20gdXNlciBzcGFjZScsIGxvYyk7XG4gICAgfVxuXG4gICAgaWYgKHBhaXIua2V5ID09PSAnbmV4dFNpYmxpbmcnKSB7XG4gICAgICBoYXNOZXh0U2libGluZyA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBsZXQgZ3VpZCA9IGIubGl0ZXJhbCgnU3RyaW5nTGl0ZXJhbCcsIGN1cnNvcik7XG4gIGxldCBndWlkUGFpciA9IGIucGFpcignZ3VpZCcsIGd1aWQpO1xuICBoYXNoLnBhaXJzLnVuc2hpZnQoZ3VpZFBhaXIpO1xuXG4gIGlmICghaGFzTmV4dFNpYmxpbmcpIHtcbiAgICBsZXQgbnVsbExpdGVyYWwgPSBiLmxpdGVyYWwoJ051bGxMaXRlcmFsJywgbnVsbCk7XG4gICAgbGV0IG5leHRTaWJsaW5nID0gYi5wYWlyKCduZXh0U2libGluZycsIG51bGxMaXRlcmFsKTtcbiAgICBoYXNoLnBhaXJzLnB1c2gobmV4dFNpYmxpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQoYXR0cmlidXRlOiBBdHRyaWJ1dGUsIHBhcnQ6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICBhdHRyaWJ1dGUuaXNEeW5hbWljID0gdHJ1ZTtcbiAgYXR0cmlidXRlLnBhcnRzLnB1c2gocGFydCk7XG59XG4iXX0=