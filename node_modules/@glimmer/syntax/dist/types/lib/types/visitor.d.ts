import { Node, Nodes, ParentNode, ParentNodeType, LeafNode, LeafNodeType, ChildKey, ChildKeyByNodeType, NodeByChildKey } from './nodes';
export declare type NodeFunction<T extends Node = Node> = (node: T) => Node | Node[] | undefined | null | void;
export declare type KeyFunction<T extends ParentNode = ParentNode, K extends ChildKey = ChildKey> = (node: T, key: K) => void;
export declare type FunctionOrEnterExit<F extends Function, K = undefined> = F | EnterExit<F, K>;
export interface EnterExit<F extends Function, K = undefined> {
    enter?: F;
    exit?: F;
    keys?: K;
}
export declare type KeyHandler<T extends ParentNode = ParentNode, K extends ChildKey = ChildKey> = FunctionOrEnterExit<KeyFunction<T, K>>;
export declare type KeysVisistor<T extends ParentNode, K extends ChildKey = ChildKeyByNodeType[T['type']]> = {
    All?: KeyHandler<T, K>;
} & {
    [P in K]?: KeyHandler<Extract<T, NodeByChildKey[P]>, P>;
};
export declare type EnterExitNodeHandler<T extends Node> = EnterExit<NodeFunction<T>, any>;
export { NodeFunction as NodeHandlerFunction };
export declare type NodeHandler<T extends Node = Node, K = KeysVisistor<ParentNode, ChildKey>> = FunctionOrEnterExit<NodeFunction<T>, K>;
export declare type LeafNodeHandler<T extends LeafNode> = NodeHandler<T, undefined>;
export declare type ParentNodeHandler<T extends ParentNode> = NodeHandler<T, KeysVisistor<T>>;
export declare type NodeVisitor = {
    All?: NodeHandler;
} & {
    [T in LeafNodeType]?: LeafNodeHandler<Nodes[T]>;
} & {
    [T in ParentNodeType]?: ParentNodeHandler<Nodes[T]>;
};
