import { EventedTokenizer } from 'simple-html-tokenizer';
import { Program } from './types/nodes';
import * as AST from './types/nodes';
import * as HandlebarsAST from './types/handlebars-ast';
import { Option } from '@glimmer/interfaces';
export declare type Element = AST.Program | AST.ElementNode;
export interface Tag<T extends 'StartTag' | 'EndTag'> {
    type: T;
    name: string;
    attributes: any[];
    modifiers: any[];
    comments: any[];
    selfClosing: boolean;
    loc: AST.SourceLocation;
}
export interface Attribute {
    name: string;
    parts: (AST.MustacheStatement | AST.TextNode)[];
    isQuoted: boolean;
    isDynamic: boolean;
    start: AST.Position;
    valueStartLine: number;
    valueStartColumn: number;
}
export declare abstract class Parser {
    protected elementStack: Element[];
    private source;
    currentAttribute: Option<Attribute>;
    currentNode: Option<AST.CommentStatement | AST.TextNode | Tag<'StartTag' | 'EndTag'>>;
    tokenizer: EventedTokenizer;
    constructor(source: string);
    abstract reset(): void;
    abstract finishData(): void;
    abstract tagOpen(): void;
    abstract beginData(): void;
    abstract appendToData(char: string): void;
    abstract beginStartTag(): void;
    abstract appendToTagName(char: string): void;
    abstract beginAttribute(): void;
    abstract appendToAttributeName(char: string): void;
    abstract beginAttributeValue(quoted: boolean): void;
    abstract appendToAttributeValue(char: string): void;
    abstract finishAttributeValue(): void;
    abstract markTagAsSelfClosing(): void;
    abstract beginEndTag(): void;
    abstract finishTag(): void;
    abstract beginComment(): void;
    abstract appendToCommentData(char: string): void;
    abstract finishComment(): void;
    abstract reportSyntaxError(error: string): void;
    readonly currentAttr: Attribute;
    readonly currentTag: Tag<'StartTag' | 'EndTag'>;
    readonly currentStartTag: Tag<'StartTag'>;
    readonly currentEndTag: Tag<'EndTag'>;
    readonly currentComment: AST.CommentStatement;
    readonly currentData: AST.TextNode;
    acceptNode(node: HandlebarsAST.Program): Program;
    acceptNode<U extends AST.Node>(node: HandlebarsAST.Node): U;
    currentElement(): Element;
    sourceForNode(node: HandlebarsAST.Node, endNode?: {
        loc: HandlebarsAST.SourceLocation;
    }): string;
}
