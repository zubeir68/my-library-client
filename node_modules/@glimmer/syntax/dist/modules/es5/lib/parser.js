var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { EventedTokenizer, EntityParser, HTML5NamedCharRefs as namedCharRefs } from 'simple-html-tokenizer';
import { assert } from '@glimmer/util';
var entityParser = new EntityParser(namedCharRefs);
export var Parser = function () {
    function Parser(source) {
        _classCallCheck(this, Parser);

        this.elementStack = [];
        this.currentAttribute = null;
        this.currentNode = null;
        this.tokenizer = new EventedTokenizer(this, entityParser);
        this.source = source.split(/(?:\r\n?|\n)/g);
    }

    Parser.prototype.acceptNode = function acceptNode(node) {
        return this[node.type](node);
    };

    Parser.prototype.currentElement = function currentElement() {
        return this.elementStack[this.elementStack.length - 1];
    };

    Parser.prototype.sourceForNode = function sourceForNode(node, endNode) {
        var firstLine = node.loc.start.line - 1;
        var currentLine = firstLine - 1;
        var firstColumn = node.loc.start.column;
        var string = [];
        var line = void 0;
        var lastLine = void 0;
        var lastColumn = void 0;
        if (endNode) {
            lastLine = endNode.loc.end.line - 1;
            lastColumn = endNode.loc.end.column;
        } else {
            lastLine = node.loc.end.line - 1;
            lastColumn = node.loc.end.column;
        }
        while (currentLine < lastLine) {
            currentLine++;
            line = this.source[currentLine];
            if (currentLine === firstLine) {
                if (firstLine === lastLine) {
                    string.push(line.slice(firstColumn, lastColumn));
                } else {
                    string.push(line.slice(firstColumn));
                }
            } else if (currentLine === lastLine) {
                string.push(line.slice(0, lastColumn));
            } else {
                string.push(line);
            }
        }
        return string.join('\n');
    };

    _createClass(Parser, [{
        key: 'currentAttr',
        get: function get() {
            return this.currentAttribute;
        }
    }, {
        key: 'currentTag',
        get: function get() {
            var node = this.currentNode;
            false && assert(node && (node.type === 'StartTag' || node.type === 'EndTag'), 'expected tag');

            return node;
        }
    }, {
        key: 'currentStartTag',
        get: function get() {
            var node = this.currentNode;
            false && assert(node && node.type === 'StartTag', 'expected start tag');

            return node;
        }
    }, {
        key: 'currentEndTag',
        get: function get() {
            var node = this.currentNode;
            false && assert(node && node.type === 'EndTag', 'expected end tag');

            return node;
        }
    }, {
        key: 'currentComment',
        get: function get() {
            var node = this.currentNode;
            false && assert(node && node.type === 'CommentStatement', 'expected a comment');

            return node;
        }
    }, {
        key: 'currentData',
        get: function get() {
            var node = this.currentNode;
            false && assert(node && node.type === 'TextNode', 'expected a text node');

            return node;
        }
    }]);

    return Parser;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLEFBQU8sU0FDTCxBQUFnQixrQkFDaEIsQUFBWSxjQUNaLEFBQWtCLHNCQUFJLEFBQWEsQUFDcEMscUJBQU0sQUFBdUIsQUFBQztBQUsvQixBQUFPLFNBQUUsQUFBTSxBQUFFLEFBQU0sQUFBRSxjQUFNLEFBQWUsQUFBQztBQUUvQyxJQUFNLEFBQVksZUFBRyxJQUFJLEFBQVksYUFBQyxBQUFhLEFBQUMsQUFBQztBQXdCckQsQUFBTSxXQVNKO29CQUFZLEFBQWM7QUFSaEI7O2FBQVksZUFBYyxBQUFFLEFBQUMsQUFFaEM7YUFBZ0IsbUJBQXNCLEFBQUksQUFBQyxBQUMzQzthQUFXLGNBRWQsQUFBSSxBQUFDLEFBQ0Y7YUFBUyxZQUFHLElBQUksQUFBZ0IsaUJBQUMsQUFBSSxNQUFFLEFBQVksQUFBQyxBQUFDLEFBRzFELEFBQUk7YUFBQyxBQUFNLFNBQUcsQUFBTSxPQUFDLEFBQUssTUFBQyxBQUFlLEFBQUMsQUFBQyxBQUM5QyxBQUFDO0FBc0JELEFBQUksQUFBVzs7c0RBb0NKLEFBQXdCLE1BQ2pDO2VBQU8sQUFBSSxLQUFDLEFBQUksS0FBQyxBQUFJLEFBQUMsTUFBQyxBQUFJLEFBQUMsQUFBQyxBQUMvQixBQUFDO0FBRUQsQUFBYzs7Z0VBQ1o7ZUFBTyxBQUFJLEtBQUMsQUFBWSxhQUFDLEFBQUksS0FBQyxBQUFZLGFBQUMsQUFBTSxTQUFHLEFBQUMsQUFBQyxBQUFDLEFBQ3pELEFBQUM7QUFFRCxBQUFhOzs0REFBQyxBQUF3QixNQUFFLEFBQStDLFNBQ3JGO1lBQUksQUFBUyxZQUFHLEFBQUksS0FBQyxBQUFHLElBQUMsQUFBSyxNQUFDLEFBQUksT0FBRyxBQUFDLEFBQUMsQUFDeEM7WUFBSSxBQUFXLGNBQUcsQUFBUyxZQUFHLEFBQUMs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RUQsQUFBSSxBQUFXOzs7NEJBQ2I7Z0JBQUksQUFBSSxPQUFHLEFBQUksS0FBQyxBQUFXLEFBQUM7cUJBQzVCLEFBQU0sT0FBQyxBQUFJLFFBQUksQUFBSSxLQUFDLEFBQUksU0FBSyxBQUFVLFlBQUUsQUFBc0IsQUFBQyxBQUFDLEFBQ2pFOzttQkFBTyxBQUFvQixBQUFDLEFBQzlCLEFBQUM7QUFJRCxBQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRXZlbnRlZFRva2VuaXplcixcbiAgRW50aXR5UGFyc2VyLFxuICBIVE1MNU5hbWVkQ2hhclJlZnMgYXMgbmFtZWRDaGFyUmVmcyxcbn0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcbmltcG9ydCB7IFByb2dyYW0gfSBmcm9tICcuL3R5cGVzL25vZGVzJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuL3R5cGVzL25vZGVzJztcbmltcG9ydCAqIGFzIEhhbmRsZWJhcnNBU1QgZnJvbSAnLi90eXBlcy9oYW5kbGViYXJzLWFzdCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IGVudGl0eVBhcnNlciA9IG5ldyBFbnRpdHlQYXJzZXIobmFtZWRDaGFyUmVmcyk7XG5cbmV4cG9ydCB0eXBlIEVsZW1lbnQgPSBBU1QuUHJvZ3JhbSB8IEFTVC5FbGVtZW50Tm9kZTtcblxuZXhwb3J0IGludGVyZmFjZSBUYWc8VCBleHRlbmRzICdTdGFydFRhZycgfCAnRW5kVGFnJz4ge1xuICB0eXBlOiBUO1xuICBuYW1lOiBzdHJpbmc7XG4gIGF0dHJpYnV0ZXM6IGFueVtdO1xuICBtb2RpZmllcnM6IGFueVtdO1xuICBjb21tZW50czogYW55W107XG4gIHNlbGZDbG9zaW5nOiBib29sZWFuO1xuICBsb2M6IEFTVC5Tb3VyY2VMb2NhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHBhcnRzOiAoQVNULk11c3RhY2hlU3RhdGVtZW50IHwgQVNULlRleHROb2RlKVtdO1xuICBpc1F1b3RlZDogYm9vbGVhbjtcbiAgaXNEeW5hbWljOiBib29sZWFuO1xuICBzdGFydDogQVNULlBvc2l0aW9uO1xuICB2YWx1ZVN0YXJ0TGluZTogbnVtYmVyO1xuICB2YWx1ZVN0YXJ0Q29sdW1uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQYXJzZXIge1xuICBwcm90ZWN0ZWQgZWxlbWVudFN0YWNrOiBFbGVtZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBzb3VyY2U6IHN0cmluZ1tdO1xuICBwdWJsaWMgY3VycmVudEF0dHJpYnV0ZTogT3B0aW9uPEF0dHJpYnV0ZT4gPSBudWxsO1xuICBwdWJsaWMgY3VycmVudE5vZGU6IE9wdGlvbjxcbiAgICBBU1QuQ29tbWVudFN0YXRlbWVudCB8IEFTVC5UZXh0Tm9kZSB8IFRhZzwnU3RhcnRUYWcnIHwgJ0VuZFRhZyc+XG4gID4gPSBudWxsO1xuICBwdWJsaWMgdG9rZW5pemVyID0gbmV3IEV2ZW50ZWRUb2tlbml6ZXIodGhpcywgZW50aXR5UGFyc2VyKTtcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IHN0cmluZykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gIH1cblxuICBhYnN0cmFjdCByZXNldCgpOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hEYXRhKCk6IHZvaWQ7XG4gIGFic3RyYWN0IHRhZ09wZW4oKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5EYXRhKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGFwcGVuZFRvRGF0YShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpblN0YXJ0VGFnKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGFwcGVuZFRvVGFnTmFtZShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkF0dHJpYnV0ZSgpOiB2b2lkO1xuICBhYnN0cmFjdCBhcHBlbmRUb0F0dHJpYnV0ZU5hbWUoY2hhcjogc3RyaW5nKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5BdHRyaWJ1dGVWYWx1ZShxdW90ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICBhYnN0cmFjdCBhcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKGNoYXI6IHN0cmluZyk6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk6IHZvaWQ7XG4gIGFic3RyYWN0IG1hcmtUYWdBc1NlbGZDbG9zaW5nKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGJlZ2luRW5kVGFnKCk6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaFRhZygpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkNvbW1lbnQoKTogdm9pZDtcbiAgYWJzdHJhY3QgYXBwZW5kVG9Db21tZW50RGF0YShjaGFyOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hDb21tZW50KCk6IHZvaWQ7XG4gIGFic3RyYWN0IHJlcG9ydFN5bnRheEVycm9yKGVycm9yOiBzdHJpbmcpOiB2b2lkO1xuXG4gIGdldCBjdXJyZW50QXR0cigpOiBBdHRyaWJ1dGUge1xuICAgIHJldHVybiBleHBlY3QodGhpcy5jdXJyZW50QXR0cmlidXRlLCAnZXhwZWN0ZWQgYXR0cmlidXRlJyk7XG4gIH1cblxuICBnZXQgY3VycmVudFRhZygpOiBUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPiB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIChub2RlLnR5cGUgPT09ICdTdGFydFRhZycgfHwgbm9kZS50eXBlID09PSAnRW5kVGFnJyksICdleHBlY3RlZCB0YWcnKTtcbiAgICByZXR1cm4gbm9kZSBhcyBUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPjtcbiAgfVxuXG4gIGdldCBjdXJyZW50U3RhcnRUYWcoKTogVGFnPCdTdGFydFRhZyc+IHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnU3RhcnRUYWcnLCAnZXhwZWN0ZWQgc3RhcnQgdGFnJyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgVGFnPCdTdGFydFRhZyc+O1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRFbmRUYWcoKTogVGFnPCdFbmRUYWcnPiB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ0VuZFRhZycsICdleHBlY3RlZCBlbmQgdGFnJyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgVGFnPCdFbmRUYWcnPjtcbiAgfVxuXG4gIGdldCBjdXJyZW50Q29tbWVudCgpOiBBU1QuQ29tbWVudFN0YXRlbWVudCB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ0NvbW1lbnRTdGF0ZW1lbnQnLCAnZXhwZWN0ZWQgYSBjb21tZW50Jyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgQVNULkNvbW1lbnRTdGF0ZW1lbnQ7XG4gIH1cblxuICBnZXQgY3VycmVudERhdGEoKTogQVNULlRleHROb2RlIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnVGV4dE5vZGUnLCAnZXhwZWN0ZWQgYSB0ZXh0IG5vZGUnKTtcbiAgICByZXR1cm4gbm9kZSBhcyBBU1QuVGV4dE5vZGU7XG4gIH1cblxuICBhY2NlcHROb2RlKG5vZGU6IEhhbmRsZWJhcnNBU1QuUHJvZ3JhbSk6IFByb2dyYW07XG4gIGFjY2VwdE5vZGU8VSBleHRlbmRzIEFTVC5Ob2RlPihub2RlOiBIYW5kbGViYXJzQVNULk5vZGUpOiBVO1xuICBhY2NlcHROb2RlKG5vZGU6IEhhbmRsZWJhcnNBU1QuTm9kZSk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXNbbm9kZS50eXBlXShub2RlKTtcbiAgfVxuXG4gIGN1cnJlbnRFbGVtZW50KCk6IEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFja1t0aGlzLmVsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHNvdXJjZUZvck5vZGUobm9kZTogSGFuZGxlYmFyc0FTVC5Ob2RlLCBlbmROb2RlPzogeyBsb2M6IEhhbmRsZWJhcnNBU1QuU291cmNlTG9jYXRpb24gfSk6IHN0cmluZyB7XG4gICAgbGV0IGZpcnN0TGluZSA9IG5vZGUubG9jLnN0YXJ0LmxpbmUgLSAxO1xuICAgIGxldCBjdXJyZW50TGluZSA9IGZpcnN0TGluZSAtIDE7XG4gICAgbGV0IGZpcnN0Q29sdW1uID0gbm9kZS5sb2Muc3RhcnQuY29sdW1uO1xuICAgIGxldCBzdHJpbmcgPSBbXTtcbiAgICBsZXQgbGluZTtcblxuICAgIGxldCBsYXN0TGluZTogbnVtYmVyO1xuICAgIGxldCBsYXN0Q29sdW1uOiBudW1iZXI7XG5cbiAgICBpZiAoZW5kTm9kZSkge1xuICAgICAgbGFzdExpbmUgPSBlbmROb2RlLmxvYy5lbmQubGluZSAtIDE7XG4gICAgICBsYXN0Q29sdW1uID0gZW5kTm9kZS5sb2MuZW5kLmNvbHVtbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdExpbmUgPSBub2RlLmxvYy5lbmQubGluZSAtIDE7XG4gICAgICBsYXN0Q29sdW1uID0gbm9kZS5sb2MuZW5kLmNvbHVtbjtcbiAgICB9XG5cbiAgICB3aGlsZSAoY3VycmVudExpbmUgPCBsYXN0TGluZSkge1xuICAgICAgY3VycmVudExpbmUrKztcbiAgICAgIGxpbmUgPSB0aGlzLnNvdXJjZVtjdXJyZW50TGluZV07XG5cbiAgICAgIGlmIChjdXJyZW50TGluZSA9PT0gZmlyc3RMaW5lKSB7XG4gICAgICAgIGlmIChmaXJzdExpbmUgPT09IGxhc3RMaW5lKSB7XG4gICAgICAgICAgc3RyaW5nLnB1c2gobGluZS5zbGljZShmaXJzdENvbHVtbiwgbGFzdENvbHVtbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmluZy5wdXNoKGxpbmUuc2xpY2UoZmlyc3RDb2x1bW4pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGluZSA9PT0gbGFzdExpbmUpIHtcbiAgICAgICAgc3RyaW5nLnB1c2gobGluZS5zbGljZSgwLCBsYXN0Q29sdW1uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmcucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nLmpvaW4oJ1xcbicpO1xuICB9XG59XG4iXX0=