import { DictSet, Option } from '@glimmer/util';
import { AST } from '@glimmer/syntax';
import { BlockSymbolTable, ProgramSymbolTable } from './template-visitor';
import { CompileOptions } from './template-compiler';
import { SerializedInlineBlock, SerializedTemplateBlock, Core, Statement, Statements, Expression, Expressions } from '@glimmer/wire-format';
import { Processor, CompilerOps, OpName, Op } from './compiler-ops';
export declare type str = string;
export declare type Params = Core.Params;
export declare type Hash = Core.Hash;
export declare type Path = Core.Path;
export declare type StackValue = Expression | Params | Hash | str;
export declare abstract class Block {
    statements: Statement[];
    abstract toJSON(): Object;
    push(statement: Statement): void;
}
export declare class InlineBlock extends Block {
    table: BlockSymbolTable;
    constructor(table: BlockSymbolTable);
    toJSON(): SerializedInlineBlock;
}
export declare class TemplateBlock extends Block {
    private symbolTable;
    type: string;
    yields: DictSet<string>;
    named: DictSet<string>;
    blocks: SerializedInlineBlock[];
    hasEval: boolean;
    constructor(symbolTable: ProgramSymbolTable);
    push(statement: Statement): void;
    toJSON(): SerializedTemplateBlock;
}
export declare class ComponentBlock extends Block {
    private tag;
    private table;
    private selfClosing;
    attributes: Statements.Attribute[];
    arguments: Statements.Argument[];
    private inParams;
    positionals: number[];
    constructor(tag: string, table: BlockSymbolTable, selfClosing: boolean);
    push(statement: Statement): void;
    toJSON(): [string, Statements.Attribute[], Core.Hash, Option<SerializedInlineBlock>];
}
export declare class Template {
    block: TemplateBlock;
    constructor(symbols: ProgramSymbolTable);
    toJSON(): SerializedTemplateBlock;
}
export declare type InVariable = number;
export declare type InOp<K extends keyof CompilerOps<InVariable> = OpName> = Op<InVariable, CompilerOps<InVariable>, K>;
export default class JavaScriptCompiler implements Processor<CompilerOps<number>, void, CompilerOps<void>> {
    static process(opcodes: InOp[], symbols: ProgramSymbolTable, options?: CompileOptions): Template;
    private template;
    private blocks;
    private opcodes;
    private values;
    private options;
    constructor(opcodes: InOp[], symbols: ProgramSymbolTable, options?: CompileOptions);
    readonly currentBlock: Block;
    process(): Template;
    startBlock(program: AST.Program): void;
    endBlock(): void;
    startProgram(): void;
    endProgram(): void;
    text(content: string): void;
    append(trusted: boolean): void;
    comment(value: string): void;
    modifier(name: string): void;
    block([name, template, inverse]: [string, number, Option<number>]): void;
    openComponent(element: AST.ElementNode): void;
    openSplattedElement(element: AST.ElementNode): void;
    openElement(element: AST.ElementNode): void;
    flushElement(): void;
    closeComponent(_element: AST.ElementNode): void;
    closeDynamicComponent(_element: AST.ElementNode): void;
    closeElement(_element: AST.ElementNode): void;
    staticAttr([name, namespace]: [string, Option<string>]): void;
    dynamicAttr([name, namespace]: [string, Option<string>]): void;
    trustingAttr([name, namespace]: [string, Option<string>]): void;
    staticArg(name: str): void;
    dynamicArg(name: str): void;
    yield(to: number): void;
    attrSplat(to: Option<number>): void;
    debugger(evalInfo: Option<Core.EvalInfo>): void;
    hasBlock(name: number): void;
    hasBlockParams(name: number): void;
    partial(evalInfo: Option<Core.EvalInfo>): void;
    literal(value: Expressions.Value | undefined): void;
    unknown(name: string): void;
    get([head, path]: [number, string[]]): void;
    maybeLocal(path: string[]): void;
    concat(): void;
    helper(name: string): void;
    prepareArray(size: number): void;
    prepareObject(size: number): void;
    endComponent(): [string, Statements.Attribute[], Core.Hash, Option<SerializedInlineBlock>];
    push(args: Statement): void;
    pushValue<S extends Expression | Params | Hash>(val: S): void;
    popValue<T extends StackValue>(): T;
}
