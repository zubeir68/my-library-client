import { Action } from './template-visitor';
import { Template } from './javascript-compiler';
import { Option } from '@glimmer/util';
import { AST } from '@glimmer/syntax';
import { Opaque } from '@glimmer/interfaces';
import { InOp as SymbolInOp } from './allocate-symbols';
export interface CompileOptions {
    meta: Opaque;
    customizeComponentName?(tag: string): string;
}
export declare const THIS = 0;
export default class TemplateCompiler {
    static compile(ast: AST.Program, options?: CompileOptions): Template;
    private templateId;
    private templateIds;
    private opcodes;
    private includeMeta;
    process(actions: Action[]): SymbolInOp[];
    startProgram([program]: [AST.Program]): void;
    endProgram(): void;
    startBlock([program]: [AST.Program]): void;
    endBlock(): void;
    text([action]: [AST.TextNode]): void;
    comment([action]: [AST.CommentStatement]): void;
    openElement([action]: [AST.ElementNode]): void;
    closeElement([action]: [AST.ElementNode]): void;
    attribute([action]: [AST.AttrNode]): void;
    modifier([action]: [AST.ElementModifierStatement]): void;
    mustache([action]: [AST.MustacheStatement]): void;
    block([action]: [AST.BlockStatement]): void;
    arg([path]: [AST.PathExpression]): void;
    mustacheExpression(expr: AST.MustacheStatement): void;
    yield(to: string, action: AST.MustacheStatement): void;
    debugger(_name: string, action: AST.MustacheStatement): void;
    hasBlock(name: string, action: AST.Call): void;
    hasBlockParams(name: string, action: AST.Call): void;
    partial(_params: AST.Expression[], action: AST.MustacheStatement): void;
    builtInHelper(expr: AST.Call): void;
    SubExpression(expr: AST.SubExpression): void;
    PathExpression(expr: AST.PathExpression): void;
    StringLiteral(action: AST.StringLiteral): void;
    BooleanLiteral(action: AST.BooleanLiteral): void;
    NumberLiteral(action: AST.NumberLiteral): void;
    NullLiteral(action: AST.NullLiteral): void;
    UndefinedLiteral(action: AST.UndefinedLiteral): void;
    opcode<O extends SymbolInOp>(opcode: O, action?: Option<AST.BaseNode>): void;
    prepareHelper(expr: AST.Call): void;
    prepareParams(params: AST.Expression[]): void;
    prepareHash(hash: AST.Hash): void;
    prepareAttributeValue(value: AST.AttrNode['value']): boolean;
    prepareConcatParts(parts: AST.ConcatStatement['parts']): void;
    attributeMustache([action]: [AST.MustacheStatement]): void;
    meta(node: AST.BaseNode): (string | (string | number[] | null)[])[];
}
