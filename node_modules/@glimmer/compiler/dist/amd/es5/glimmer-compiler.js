define('@glimmer/compiler', ['exports', '@glimmer/syntax', '@glimmer/util', '@glimmer/wire-format'], function (exports, syntax, util, wireFormat) { 'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SymbolTable = function () {
    function SymbolTable() {
        _classCallCheck$1(this, SymbolTable);
    }

    SymbolTable.top = function top() {
        return new ProgramSymbolTable();
    };

    SymbolTable.prototype.child = function child(locals) {
        var _this = this;

        var symbols = locals.map(function (name) {
            return _this.allocate(name);
        });
        return new BlockSymbolTable(this, locals, symbols);
    };

    return SymbolTable;
}();
var ProgramSymbolTable = function (_SymbolTable) {
    _inherits(ProgramSymbolTable, _SymbolTable);

    function ProgramSymbolTable() {
        _classCallCheck$1(this, ProgramSymbolTable);

        var _this2 = _possibleConstructorReturn(this, _SymbolTable.apply(this, arguments));

        _this2.symbols = [];
        _this2.size = 1;
        _this2.named = util.dict();
        _this2.blocks = util.dict();
        return _this2;
    }

    ProgramSymbolTable.prototype.has = function has(_name) {
        return false;
    };

    ProgramSymbolTable.prototype.get = function get(_name) {
        throw util.unreachable();
    };

    ProgramSymbolTable.prototype.getLocalsMap = function getLocalsMap() {
        return {};
    };

    ProgramSymbolTable.prototype.getEvalInfo = function getEvalInfo() {
        return [];
    };

    ProgramSymbolTable.prototype.allocateNamed = function allocateNamed(name) {
        var named = this.named[name];
        if (!named) {
            named = this.named[name] = this.allocate(name);
        }
        return named;
    };

    ProgramSymbolTable.prototype.allocateBlock = function allocateBlock(name) {
        var block = this.blocks[name];
        if (!block) {
            block = this.blocks[name] = this.allocate('&' + name);
        }
        return block;
    };

    ProgramSymbolTable.prototype.allocate = function allocate(identifier) {
        this.symbols.push(identifier);
        return this.size++;
    };

    return ProgramSymbolTable;
}(SymbolTable);
var BlockSymbolTable = function (_SymbolTable2) {
    _inherits(BlockSymbolTable, _SymbolTable2);

    function BlockSymbolTable(parent, symbols, slots) {
        _classCallCheck$1(this, BlockSymbolTable);

        var _this3 = _possibleConstructorReturn(this, _SymbolTable2.call(this));

        _this3.parent = parent;
        _this3.symbols = symbols;
        _this3.slots = slots;
        return _this3;
    }

    BlockSymbolTable.prototype.has = function has(name) {
        return this.symbols.indexOf(name) !== -1 || this.parent.has(name);
    };

    BlockSymbolTable.prototype.get = function get(name) {
        var slot = this.symbols.indexOf(name);
        return slot === -1 ? this.parent.get(name) : this.slots[slot];
    };

    BlockSymbolTable.prototype.getLocalsMap = function getLocalsMap() {
        var _this4 = this;

        var dict$$1 = this.parent.getLocalsMap();
        this.symbols.forEach(function (symbol) {
            return dict$$1[symbol] = _this4.get(symbol);
        });
        return dict$$1;
    };

    BlockSymbolTable.prototype.getEvalInfo = function getEvalInfo() {
        var locals = this.getLocalsMap();
        return Object.keys(locals).map(function (symbol) {
            return locals[symbol];
        });
    };

    BlockSymbolTable.prototype.allocateNamed = function allocateNamed(name) {
        return this.parent.allocateNamed(name);
    };

    BlockSymbolTable.prototype.allocateBlock = function allocateBlock(name) {
        return this.parent.allocateBlock(name);
    };

    BlockSymbolTable.prototype.allocate = function allocate(identifier) {
        return this.parent.allocate(identifier);
    };

    return BlockSymbolTable;
}(SymbolTable);
/**
 * Takes in an AST and outputs a list of actions to be consumed
 * by a compiler. For example, the template
 *
 *     foo{{bar}}<div>baz</div>
 *
 * produces the actions
 *
 *     [['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 3]],
 *      ['mustache', [mustacheNode, 1, 3]],
 *      ['openElement', [elementNode, 2, 3, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['closeElement', [elementNode, 2, 3],
 *      ['endProgram', [programNode]]]
 *
 * This visitor walks the AST depth first and backwards. As
 * a result the bottom-most child template will appear at the
 * top of the actions list whereas the root template will appear
 * at the bottom of the list. For example,
 *
 *     <div>{{#if}}foo{{else}}bar<b></b>{{/if}}</div>
 *
 * produces the actions
 *
 *     [['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 2, 0]],
 *      ['openElement', [elementNode, 1, 2, 0]],
 *      ['closeElement', [elementNode, 1, 2]],
 *      ['endProgram', [programNode]],
 *      ['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['endProgram', [programNode]],
 *      ['startProgram', [programNode, 2]],
 *      ['openElement', [elementNode, 0, 1, 1]],
 *      ['block', [blockNode, 0, 1]],
 *      ['closeElement', [elementNode, 0, 1]],
 *      ['endProgram', [programNode]]]
 *
 * The state of the traversal is maintained by a stack of frames.
 * Whenever a node with children is entered (either a ProgramNode
 * or an ElementNode) a frame is pushed onto the stack. The frame
 * contains information about the state of the traversal of that
 * node. For example,
 *
 *   - index of the current child node being visited
 *   - the number of mustaches contained within its child nodes
 *   - the list of actions generated by its child nodes
 */

var Frame = function Frame() {
    _classCallCheck$1(this, Frame);

    this.parentNode = null;
    this.children = null;
    this.childIndex = null;
    this.childCount = null;
    this.childTemplateCount = 0;
    this.mustacheCount = 0;
    this.actions = [];
    this.blankChildTextNodes = null;
    this.symbols = null;
};

var TemplateVisitor = function () {
    function TemplateVisitor() {
        _classCallCheck$1(this, TemplateVisitor);

        this.frameStack = [];
        this.actions = [];
        this.programDepth = -1;
    }

    TemplateVisitor.prototype.visit = function visit(node) {
        this[node.type](node);
    };
    // Traversal methods


    TemplateVisitor.prototype.Program = function Program(program) {
        var _actions;

        this.programDepth++;
        var parentFrame = this.getCurrentFrame();
        var programFrame = this.pushFrame();
        if (!parentFrame) {
            program['symbols'] = SymbolTable.top();
        } else {
            program['symbols'] = parentFrame.symbols.child(program.blockParams);
        }
        var startType = void 0,
            endType = void 0;
        if (this.programDepth === 0) {
            startType = 'startProgram';
            endType = 'endProgram';
        } else {
            startType = 'startBlock';
            endType = 'endBlock';
        }
        programFrame.parentNode = program;
        programFrame.children = program.body;
        programFrame.childCount = program.body.length;
        programFrame.blankChildTextNodes = [];
        programFrame.actions.push([endType, [program, this.programDepth]]);
        programFrame.symbols = program['symbols'];
        for (var i = program.body.length - 1; i >= 0; i--) {
            programFrame.childIndex = i;
            this.visit(program.body[i]);
        }
        programFrame.actions.push([startType, [program, programFrame.childTemplateCount, programFrame.blankChildTextNodes.reverse()]]);
        this.popFrame();
        this.programDepth--;
        // Push the completed template into the global actions list
        if (parentFrame) {
            parentFrame.childTemplateCount++;
        }
        (_actions = this.actions).push.apply(_actions, programFrame.actions.reverse());
    };

    TemplateVisitor.prototype.ElementNode = function ElementNode(element) {
        var _parentFrame$actions;

        var parentFrame = this.currentFrame;
        var elementFrame = this.pushFrame();
        elementFrame.parentNode = element;
        elementFrame.children = element.children;
        elementFrame.childCount = element.children.length;
        elementFrame.mustacheCount += element.modifiers.length;
        elementFrame.blankChildTextNodes = [];
        elementFrame.symbols = element['symbols'] = parentFrame.symbols.child(element.blockParams);
        var actionArgs = [element, parentFrame.childIndex, parentFrame.childCount];
        elementFrame.actions.push(['closeElement', actionArgs]);
        for (var i = element.attributes.length - 1; i >= 0; i--) {
            this.visit(element.attributes[i]);
        }
        for (var _i = element.children.length - 1; _i >= 0; _i--) {
            elementFrame.childIndex = _i;
            this.visit(element.children[_i]);
        }
        var open = ['openElement', [].concat(actionArgs, [elementFrame.mustacheCount, elementFrame.blankChildTextNodes.reverse()])];
        elementFrame.actions.push(open);
        this.popFrame();
        // Propagate the element's frame state to the parent frame
        if (elementFrame.mustacheCount > 0) {
            parentFrame.mustacheCount++;
        }
        parentFrame.childTemplateCount += elementFrame.childTemplateCount;
        (_parentFrame$actions = parentFrame.actions).push.apply(_parentFrame$actions, elementFrame.actions);
    };

    TemplateVisitor.prototype.AttrNode = function AttrNode(attr) {
        if (attr.value.type !== 'TextNode') {
            this.currentFrame.mustacheCount++;
        }
    };

    TemplateVisitor.prototype.TextNode = function TextNode(text) {
        var frame = this.currentFrame;
        if (text.chars === '') {
            frame.blankChildTextNodes.push(domIndexOf(frame.children, text));
        }
        frame.actions.push(['text', [text, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.BlockStatement = function BlockStatement(node) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['block', [node, frame.childIndex, frame.childCount]]);
        if (node.inverse) {
            this.visit(node.inverse);
        }
        if (node.program) {
            this.visit(node.program);
        }
    };

    TemplateVisitor.prototype.PartialStatement = function PartialStatement(node) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [node, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.CommentStatement = function CommentStatement(text) {
        var frame = this.currentFrame;
        frame.actions.push(['comment', [text, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.MustacheCommentStatement = function MustacheCommentStatement() {
        // Intentional empty: Handlebars comments should not affect output.
    };

    TemplateVisitor.prototype.MustacheStatement = function MustacheStatement(mustache) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [mustache, frame.childIndex, frame.childCount]]);
    };
    // Frame helpers


    TemplateVisitor.prototype.getCurrentFrame = function getCurrentFrame() {
        return this.frameStack[this.frameStack.length - 1];
    };

    TemplateVisitor.prototype.pushFrame = function pushFrame() {
        var frame = new Frame();
        this.frameStack.push(frame);
        return frame;
    };

    TemplateVisitor.prototype.popFrame = function popFrame() {
        return this.frameStack.pop();
    };

    _createClass(TemplateVisitor, [{
        key: 'currentFrame',
        get: function get() {
            return this.getCurrentFrame();
        }
    }]);

    return TemplateVisitor;
}();
function domIndexOf(nodes, domNode) {
    var index = -1;
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.type !== 'TextNode' && node.type !== 'ElementNode') {
            continue;
        } else {
            index++;
        }
        if (node === domNode) {
            return index;
        }
    }
    return -1;
}

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defaults$1(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults$1(subClass, superClass); }

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Block = function () {
    function Block() {
        _classCallCheck$2(this, Block);

        this.statements = [];
    }

    Block.prototype.push = function push(statement) {
        this.statements.push(statement);
    };

    return Block;
}();
var InlineBlock = function (_Block) {
    _inherits$1(InlineBlock, _Block);

    function InlineBlock(table) {
        _classCallCheck$2(this, InlineBlock);

        var _this = _possibleConstructorReturn$1(this, _Block.call(this));

        _this.table = table;
        return _this;
    }

    InlineBlock.prototype.toJSON = function toJSON() {
        return {
            statements: this.statements,
            parameters: this.table.slots
        };
    };

    return InlineBlock;
}(Block);
var TemplateBlock = function (_Block2) {
    _inherits$1(TemplateBlock, _Block2);

    function TemplateBlock(symbolTable) {
        _classCallCheck$2(this, TemplateBlock);

        var _this2 = _possibleConstructorReturn$1(this, _Block2.call(this));

        _this2.symbolTable = symbolTable;
        _this2.type = 'template';
        _this2.yields = new util.DictSet();
        _this2.named = new util.DictSet();
        _this2.blocks = [];
        _this2.hasEval = false;
        return _this2;
    }

    TemplateBlock.prototype.push = function push(statement) {
        this.statements.push(statement);
    };

    TemplateBlock.prototype.toJSON = function toJSON() {
        return {
            symbols: this.symbolTable.symbols,
            statements: this.statements,
            hasEval: this.hasEval
        };
    };

    return TemplateBlock;
}(Block);
var ComponentBlock = function (_Block3) {
    _inherits$1(ComponentBlock, _Block3);

    function ComponentBlock(tag, table, selfClosing) {
        _classCallCheck$2(this, ComponentBlock);

        var _this3 = _possibleConstructorReturn$1(this, _Block3.call(this));

        _this3.tag = tag;
        _this3.table = table;
        _this3.selfClosing = selfClosing;
        _this3.attributes = [];
        _this3.arguments = [];
        _this3.inParams = true;
        _this3.positionals = [];
        return _this3;
    }

    ComponentBlock.prototype.push = function push(statement) {
        if (this.inParams) {
            if (wireFormat.isFlushElement(statement)) {
                this.inParams = false;
            } else if (wireFormat.isArgument(statement)) {
                this.arguments.push(statement);
            } else if (wireFormat.isAttribute(statement)) {
                this.attributes.push(statement);
            } else if (wireFormat.isAttrSplat(statement)) {
                this.attributes.push(statement);
            } else {
                throw new Error('Compile Error: only parameters allowed before flush-element');
            }
        } else {
            this.statements.push(statement);
        }
    };

    ComponentBlock.prototype.toJSON = function toJSON() {
        var args = this.arguments;
        var keys = args.map(function (arg) {
            return arg[1];
        });
        var values = args.map(function (arg) {
            return arg[2];
        });
        var block = this.selfClosing ? null : {
            statements: this.statements,
            parameters: this.table.slots
        };
        return [this.tag, this.attributes, [keys, values], block];
    };

    return ComponentBlock;
}(Block);
var Template = function () {
    function Template(symbols) {
        _classCallCheck$2(this, Template);

        this.block = new TemplateBlock(symbols);
    }

    Template.prototype.toJSON = function toJSON() {
        return this.block.toJSON();
    };

    return Template;
}();

var JavaScriptCompiler = function () {
    function JavaScriptCompiler(opcodes, symbols, options) {
        _classCallCheck$2(this, JavaScriptCompiler);

        this.blocks = new util.Stack();
        this.values = [];
        this.opcodes = opcodes;
        this.template = new Template(symbols);
        this.options = options;
    }

    JavaScriptCompiler.process = function process(opcodes, symbols, options) {
        var compiler = new JavaScriptCompiler(opcodes, symbols, options);
        return compiler.process();
    };

    JavaScriptCompiler.prototype.process = function process() {
        var _this4 = this;

        this.opcodes.forEach(function (op) {
            var opcode = op[0];
            var arg = op[1];
            if (!_this4[opcode]) {
                throw new Error('unimplemented ' + opcode + ' on JavaScriptCompiler');
            }
            _this4[opcode](arg);
        });
        return this.template;
    };
    /// Nesting


    JavaScriptCompiler.prototype.startBlock = function startBlock(program) {
        var block = new InlineBlock(program['symbols']);
        this.blocks.push(block);
    };

    JavaScriptCompiler.prototype.endBlock = function endBlock() {
        var template = this.template,
            blocks = this.blocks;

        var block = blocks.pop();
        template.block.blocks.push(block.toJSON());
    };

    JavaScriptCompiler.prototype.startProgram = function startProgram() {
        this.blocks.push(this.template.block);
    };

    JavaScriptCompiler.prototype.endProgram = function endProgram() {};
    /// Statements


    JavaScriptCompiler.prototype.text = function text(content) {
        this.push([wireFormat.Ops.Text, content]);
    };

    JavaScriptCompiler.prototype.append = function append(trusted) {
        this.push([wireFormat.Ops.Append, this.popValue(), trusted]);
    };

    JavaScriptCompiler.prototype.comment = function comment(value) {
        this.push([wireFormat.Ops.Comment, value]);
    };

    JavaScriptCompiler.prototype.modifier = function modifier(name) {
        var params = this.popValue();
        var hash = this.popValue();
        this.push([wireFormat.Ops.Modifier, name, params, hash]);
    };

    JavaScriptCompiler.prototype.block = function block(_ref) {
        var name = _ref[0],
            template = _ref[1],
            inverse = _ref[2];

        var params = this.popValue();
        var hash = this.popValue();
        var blocks = this.template.block.blocks;
        this.push([wireFormat.Ops.Block, name, params, hash, blocks[template], blocks[inverse]]);
    };

    JavaScriptCompiler.prototype.openComponent = function openComponent(element) {
        var tag = this.options && this.options.customizeComponentName ? this.options.customizeComponentName(element.tag) : element.tag;
        var component = new ComponentBlock(tag, element['symbols'], element.selfClosing);
        this.blocks.push(component);
    };

    JavaScriptCompiler.prototype.openSplattedElement = function openSplattedElement(element) {
        var tag = element.tag;
        if (element.blockParams.length > 0) {
            throw new Error('Compile Error: <' + element.tag + '> is not a component and doesn\'t support block parameters');
        } else {
            this.push([wireFormat.Ops.OpenSplattedElement, tag]);
        }
    };

    JavaScriptCompiler.prototype.openElement = function openElement(element) {
        var tag = element.tag;
        if (element.blockParams.length > 0) {
            throw new Error('Compile Error: <' + element.tag + '> is not a component and doesn\'t support block parameters');
        } else {
            this.push([wireFormat.Ops.OpenElement, tag]);
        }
    };

    JavaScriptCompiler.prototype.flushElement = function flushElement() {
        this.push([wireFormat.Ops.FlushElement]);
    };

    JavaScriptCompiler.prototype.closeComponent = function closeComponent(_element) {
        if (_element.modifiers.length > 0) {
            throw new Error('Compile Error: Element modifiers are not allowed in components');
        }

        var _endComponent = this.endComponent(),
            tag = _endComponent[0],
            attrs = _endComponent[1],
            args = _endComponent[2],
            block = _endComponent[3];

        this.push([wireFormat.Ops.Component, tag, attrs, args, block]);
    };

    JavaScriptCompiler.prototype.closeDynamicComponent = function closeDynamicComponent(_element) {
        var _endComponent2 = this.endComponent(),
            attrs = _endComponent2[1],
            args = _endComponent2[2],
            block = _endComponent2[3];

        this.push([wireFormat.Ops.DynamicComponent, this.popValue(), attrs, args, block]);
    };

    JavaScriptCompiler.prototype.closeElement = function closeElement(_element) {
        this.push([wireFormat.Ops.CloseElement]);
    };

    JavaScriptCompiler.prototype.staticAttr = function staticAttr(_ref2) {
        var name = _ref2[0],
            namespace = _ref2[1];

        var value = this.popValue();
        this.push([wireFormat.Ops.StaticAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.dynamicAttr = function dynamicAttr(_ref3) {
        var name = _ref3[0],
            namespace = _ref3[1];

        var value = this.popValue();
        this.push([wireFormat.Ops.DynamicAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.trustingAttr = function trustingAttr(_ref4) {
        var name = _ref4[0],
            namespace = _ref4[1];

        var value = this.popValue();
        this.push([wireFormat.Ops.TrustingAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.staticArg = function staticArg(name) {
        var value = this.popValue();
        this.push([wireFormat.Ops.StaticArg, name, value]);
    };

    JavaScriptCompiler.prototype.dynamicArg = function dynamicArg(name) {
        var value = this.popValue();
        this.push([wireFormat.Ops.DynamicArg, name, value]);
    };

    JavaScriptCompiler.prototype.yield = function _yield(to) {
        var params = this.popValue();
        this.push([wireFormat.Ops.Yield, to, params]);
    };

    JavaScriptCompiler.prototype.attrSplat = function attrSplat(to) {
        this.push([wireFormat.Ops.AttrSplat, to]);
    };

    JavaScriptCompiler.prototype.debugger = function _debugger(evalInfo) {
        this.push([wireFormat.Ops.Debugger, evalInfo]);
        this.template.block.hasEval = true;
    };

    JavaScriptCompiler.prototype.hasBlock = function hasBlock(name) {
        this.pushValue([wireFormat.Ops.HasBlock, name]);
    };

    JavaScriptCompiler.prototype.hasBlockParams = function hasBlockParams(name) {
        this.pushValue([wireFormat.Ops.HasBlockParams, name]);
    };

    JavaScriptCompiler.prototype.partial = function partial(evalInfo) {
        var params = this.popValue();
        this.push([wireFormat.Ops.Partial, params[0], evalInfo]);
        this.template.block.hasEval = true;
    };
    /// Expressions


    JavaScriptCompiler.prototype.literal = function literal(value) {
        if (value === undefined) {
            this.pushValue([wireFormat.Ops.Undefined]);
        } else {
            this.pushValue(value);
        }
    };

    JavaScriptCompiler.prototype.unknown = function unknown(name) {
        this.pushValue([wireFormat.Ops.Unknown, name]);
    };

    JavaScriptCompiler.prototype.get = function get(_ref5) {
        var head = _ref5[0],
            path = _ref5[1];

        this.pushValue([wireFormat.Ops.Get, head, path]);
    };

    JavaScriptCompiler.prototype.maybeLocal = function maybeLocal(path) {
        this.pushValue([wireFormat.Ops.MaybeLocal, path]);
    };

    JavaScriptCompiler.prototype.concat = function concat() {
        this.pushValue([wireFormat.Ops.Concat, this.popValue()]);
    };

    JavaScriptCompiler.prototype.helper = function helper(name) {
        var params = this.popValue();
        var hash = this.popValue();
        this.pushValue([wireFormat.Ops.Helper, name, params, hash]);
    };
    /// Stack Management Opcodes


    JavaScriptCompiler.prototype.prepareArray = function prepareArray(size) {
        var values = [];
        for (var i = 0; i < size; i++) {
            values.push(this.popValue());
        }
        this.pushValue(values);
    };

    JavaScriptCompiler.prototype.prepareObject = function prepareObject(size) {
        var keys = new Array(size);
        var values = new Array(size);
        for (var i = 0; i < size; i++) {
            keys[i] = this.popValue();
            values[i] = this.popValue();
        }
        this.pushValue([keys, values]);
    };
    /// Utilities


    JavaScriptCompiler.prototype.endComponent = function endComponent() {
        var component = this.blocks.pop();
        return component.toJSON();
    };

    JavaScriptCompiler.prototype.push = function push(args) {
        while (args[args.length - 1] === null) {
            args.pop();
        }
        this.currentBlock.push(args);
    };

    JavaScriptCompiler.prototype.pushValue = function pushValue(val) {
        this.values.push(val);
    };

    JavaScriptCompiler.prototype.popValue = function popValue() {
        return this.values.pop();
    };

    _createClass$1(JavaScriptCompiler, [{
        key: 'currentBlock',
        get: function get() {
            return this.blocks.current;
        }
    }]);

    return JavaScriptCompiler;
}();

// There is a small whitelist of namespaced attributes specially
// enumerated in
// https://www.w3.org/TR/html/syntax.html#attributes-0
//
// > When a foreign element has one of the namespaced attributes given by
// > the local name and namespace of the first and second cells of a row
// > from the following table, it must be written using the name given by
// > the third cell from the same row.
//
// In all other cases, colons are interpreted as a regular character
// with no special meaning:
//
// > No other namespaced attribute can be expressed in the HTML syntax.
var XLINK = 'http://www.w3.org/1999/xlink';
var XML = 'http://www.w3.org/XML/1998/namespace';
var XMLNS = 'http://www.w3.org/2000/xmlns/';
var WHITELIST = {
    'xlink:actuate': XLINK,
    'xlink:arcrole': XLINK,
    'xlink:href': XLINK,
    'xlink:role': XLINK,
    'xlink:show': XLINK,
    'xlink:title': XLINK,
    'xlink:type': XLINK,
    'xml:base': XML,
    'xml:lang': XML,
    'xml:space': XML,
    xmlns: XMLNS,
    'xmlns:xlink': XMLNS
};
function getAttrNamespace(attrName) {
    return WHITELIST[attrName] || null;
}

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SymbolAllocator = function () {
    function SymbolAllocator(ops) {
        _classCallCheck$3(this, SymbolAllocator);

        this.ops = ops;
        this.symbolStack = new util.Stack();
    }

    SymbolAllocator.prototype.process = function process() {
        var out = [];
        var ops = this.ops;

        for (var i = 0; i < ops.length; i++) {
            var op = ops[i];
            var result = this.dispatch(op);
            if (result === undefined) {
                out.push(op);
            } else {
                out.push(result);
            }
        }
        return out;
    };

    SymbolAllocator.prototype.dispatch = function dispatch(op) {
        var name = op[0];
        var operand = op[1];
        return this[name](operand);
    };

    SymbolAllocator.prototype.startProgram = function startProgram(op) {
        this.symbolStack.push(op['symbols']);
    };

    SymbolAllocator.prototype.endProgram = function endProgram(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.startBlock = function startBlock(op) {
        this.symbolStack.push(op['symbols']);
    };

    SymbolAllocator.prototype.endBlock = function endBlock(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.flushElement = function flushElement(op) {
        this.symbolStack.push(op['symbols']);
    };

    SymbolAllocator.prototype.closeElement = function closeElement(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.closeComponent = function closeComponent(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.closeDynamicComponent = function closeDynamicComponent(_op) {
        this.symbolStack.pop();
    };

    SymbolAllocator.prototype.attrSplat = function attrSplat(_op) {
        return ['attrSplat', this.symbols.allocateBlock('attrs')];
    };

    SymbolAllocator.prototype.get = function get(op) {
        var name = op[0],
            rest = op[1];

        if (name === 0) {
            return ['get', [0, rest]];
        }
        if (isLocal(name, this.symbols)) {
            var head = this.symbols.get(name);
            return ['get', [head, rest]];
        } else if (name[0] === '@') {
            var _head = this.symbols.allocateNamed(name);
            return ['get', [_head, rest]];
        } else {
            return ['maybeLocal', [name].concat(rest)];
        }
    };

    SymbolAllocator.prototype.maybeGet = function maybeGet(op) {
        var name = op[0],
            rest = op[1];

        if (name === 0) {
            return ['get', [0, rest]];
        }
        if (isLocal(name, this.symbols)) {
            var head = this.symbols.get(name);
            return ['get', [head, rest]];
        } else if (name[0] === '@') {
            var _head2 = this.symbols.allocateNamed(name);
            return ['get', [_head2, rest]];
        } else if (rest.length === 0) {
            return ['unknown', name];
        } else {
            return ['maybeLocal', [name].concat(rest)];
        }
    };

    SymbolAllocator.prototype.yield = function _yield(op) {
        if (op === 0) {
            throw new Error('Cannot yield to this');
        }
        return ['yield', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.debugger = function _debugger(_op) {
        return ['debugger', this.symbols.getEvalInfo()];
    };

    SymbolAllocator.prototype.hasBlock = function hasBlock(op) {
        if (op === 0) {
            throw new Error('Cannot hasBlock this');
        }
        return ['hasBlock', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.hasBlockParams = function hasBlockParams(op) {
        if (op === 0) {
            throw new Error('Cannot hasBlockParams this');
        }
        return ['hasBlockParams', this.symbols.allocateBlock(op)];
    };

    SymbolAllocator.prototype.partial = function partial(_op) {
        return ['partial', this.symbols.getEvalInfo()];
    };

    SymbolAllocator.prototype.text = function text(_op) {};

    SymbolAllocator.prototype.comment = function comment(_op) {};

    SymbolAllocator.prototype.openComponent = function openComponent(_op) {};

    SymbolAllocator.prototype.openElement = function openElement(_op) {};

    SymbolAllocator.prototype.openSplattedElement = function openSplattedElement(_op) {};

    SymbolAllocator.prototype.staticArg = function staticArg(_op) {};

    SymbolAllocator.prototype.dynamicArg = function dynamicArg(_op) {};

    SymbolAllocator.prototype.staticAttr = function staticAttr(_op) {};

    SymbolAllocator.prototype.trustingAttr = function trustingAttr(_op) {};

    SymbolAllocator.prototype.dynamicAttr = function dynamicAttr(_op) {};

    SymbolAllocator.prototype.modifier = function modifier(_op) {};

    SymbolAllocator.prototype.append = function append(_op) {};

    SymbolAllocator.prototype.block = function block(_op) {};

    SymbolAllocator.prototype.literal = function literal(_op) {};

    SymbolAllocator.prototype.helper = function helper(_op) {};

    SymbolAllocator.prototype.unknown = function unknown(_op) {};

    SymbolAllocator.prototype.maybeLocal = function maybeLocal(_op) {};

    SymbolAllocator.prototype.prepareArray = function prepareArray(_op) {};

    SymbolAllocator.prototype.prepareObject = function prepareObject(_op) {};

    SymbolAllocator.prototype.concat = function concat(_op) {};

    _createClass$2(SymbolAllocator, [{
        key: 'symbols',
        get: function get() {
            return this.symbolStack.current;
        }
    }]);

    return SymbolAllocator;
}();
function isLocal(name, symbols) {
    return symbols && symbols.has(name);
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isTrustedValue(value) {
    return value.escaped !== undefined && !value.escaped;
}


var TemplateCompiler = function () {
    function TemplateCompiler() {
        _classCallCheck(this, TemplateCompiler);

        this.templateId = 0;
        this.templateIds = [];
        this.opcodes = [];
        this.includeMeta = false;
    }

    TemplateCompiler.compile = function compile(ast, options) {
        var templateVisitor = new TemplateVisitor();
        templateVisitor.visit(ast);
        var compiler = new TemplateCompiler();
        var opcodes = compiler.process(templateVisitor.actions);
        var symbols = new SymbolAllocator(opcodes).process();
        return JavaScriptCompiler.process(symbols, ast['symbols'], options);
    };

    TemplateCompiler.prototype.process = function process(actions) {
        var _this = this;

        actions.forEach(function (_ref) {
            var name = _ref[0],
                args = _ref.slice(1);

            if (!_this[name]) {
                throw new Error('Unimplemented ' + name + ' on TemplateCompiler');
            }
            _this[name].apply(_this, args);
        });
        return this.opcodes;
    };

    TemplateCompiler.prototype.startProgram = function startProgram(_ref2) {
        var program = _ref2[0];

        this.opcode(['startProgram', program], program);
    };

    TemplateCompiler.prototype.endProgram = function endProgram() {
        this.opcode(['endProgram', null], null);
    };

    TemplateCompiler.prototype.startBlock = function startBlock(_ref3) {
        var program = _ref3[0];

        this.templateId++;
        this.opcode(['startBlock', program], program);
    };

    TemplateCompiler.prototype.endBlock = function endBlock() {
        this.templateIds.push(this.templateId - 1);
        this.opcode(['endBlock', null], null);
    };

    TemplateCompiler.prototype.text = function text(_ref4) {
        var action = _ref4[0];

        this.opcode(['text', action.chars], action);
    };

    TemplateCompiler.prototype.comment = function comment(_ref5) {
        var action = _ref5[0];

        this.opcode(['comment', action.value], action);
    };

    TemplateCompiler.prototype.openElement = function openElement(_ref6) {
        var action = _ref6[0];

        var attributes = action.attributes;
        var hasSplat = void 0;
        for (var i = 0; i < attributes.length; i++) {
            var attr = attributes[i];
            if (attr.name === '...attributes') {
                hasSplat = attr;
                break;
            }
        }
        if (isDynamicComponent(action)) {
            var head = void 0,
                rest = void 0;

            var _action$tag$split = action.tag.split('.');

            head = _action$tag$split[0];
            rest = _action$tag$split.slice(1);

            if (head === 'this') {
                head = 0;
            }
            this.opcode(['get', [head, rest]]);
            this.opcode(['openComponent', action], action);
        } else if (isComponent(action)) {
            this.opcode(['openComponent', action], action);
        } else if (hasSplat) {
            this.opcode(['openSplattedElement', action], action);
        } else {
            this.opcode(['openElement', action], action);
        }
        var typeAttr = null;
        var attrs = action.attributes;
        for (var _i = 0; _i < attrs.length; _i++) {
            if (attrs[_i].name === 'type') {
                typeAttr = attrs[_i];
                continue;
            }
            this.attribute([attrs[_i]]);
        }
        if (typeAttr) {
            this.attribute([typeAttr]);
        }
        this.opcode(['flushElement', action], null);
    };

    TemplateCompiler.prototype.closeElement = function closeElement(_ref7) {
        var action = _ref7[0];

        if (isDynamicComponent(action)) {
            this.opcode(['closeDynamicComponent', action], action);
        } else if (isComponent(action)) {
            this.opcode(['closeComponent', action], action);
        } else if (action.modifiers.length > 0) {
            for (var i = 0; i < action.modifiers.length; i++) {
                this.modifier([action.modifiers[i]]);
            }
            this.opcode(['closeElement', action], action);
        } else {
            this.opcode(['closeElement', action], action);
        }
    };

    TemplateCompiler.prototype.attribute = function attribute(_ref8) {
        var action = _ref8[0];
        var name = action.name,
            value = action.value;

        var namespace = getAttrNamespace(name);
        var isStatic = this.prepareAttributeValue(value);
        if (name.charAt(0) === '@') {
            // Arguments
            if (isStatic) {
                this.opcode(['staticArg', name], action);
            } else if (action.value.type === 'MustacheStatement') {
                this.opcode(['dynamicArg', name], action);
            } else {
                this.opcode(['dynamicArg', name], action);
            }
        } else {
            var isTrusting = isTrustedValue(value);
            if (isStatic && name === '...attributes') {
                this.opcode(['attrSplat', null], action);
            } else if (isStatic) {
                this.opcode(['staticAttr', [name, namespace]], action);
            } else if (isTrusting) {
                this.opcode(['trustingAttr', [name, namespace]], action);
            } else if (action.value.type === 'MustacheStatement') {
                this.opcode(['dynamicAttr', [name, null]], action);
            } else {
                this.opcode(['dynamicAttr', [name, namespace]], action);
            }
        }
    };

    TemplateCompiler.prototype.modifier = function modifier(_ref9) {
        var action = _ref9[0];

        assertIsSimplePath(action.path, action.loc, 'modifier');
        var parts = action.path.parts;

        this.prepareHelper(action);
        this.opcode(['modifier', parts[0]], action);
    };

    TemplateCompiler.prototype.mustache = function mustache(_ref10) {
        var action = _ref10[0];
        var path = action.path;

        if (syntax.isLiteral(path)) {
            this.mustacheExpression(action);
            this.opcode(['append', !action.escaped], action);
        } else if (isYield(path)) {
            var to = assertValidYield(action);
            this.yield(to, action);
        } else if (isPartial(path)) {
            var params = assertValidPartial(action);
            this.partial(params, action);
        } else if (isDebugger(path)) {
            assertValidDebuggerUsage(action);
            this.debugger('debugger', action);
        } else {
            this.mustacheExpression(action);
            this.opcode(['append', !action.escaped], action);
        }
    };

    TemplateCompiler.prototype.block = function block(_ref11) {
        var action /*, index, count*/ = _ref11[0];

        this.prepareHelper(action);
        var templateId = this.templateIds.pop();
        var inverseId = action.inverse === null ? null : this.templateIds.pop();
        this.opcode(['block', [action.path.parts[0], templateId, inverseId]], action);
    };
    /// Internal actions, not found in the original processed actions


    TemplateCompiler.prototype.arg = function arg(_ref12) {
        var path = _ref12[0];

        var _path$parts = path.parts,
            head = _path$parts[0],
            rest = _path$parts.slice(1);

        this.opcode(['get', ['@' + head, rest]], path);
    };

    TemplateCompiler.prototype.mustacheExpression = function mustacheExpression(expr) {
        var path = expr.path;

        if (syntax.isLiteral(path)) {
            this.opcode(['literal', path.value], expr);
        } else if (isBuiltInHelper(path)) {
            this.builtInHelper(expr);
        } else if (isArg(path)) {
            this.arg([path]);
        } else if (isHelperInvocation(expr)) {
            this.prepareHelper(expr);
            this.opcode(['helper', path.parts[0]], expr);
        } else if (path.this) {
            this.opcode(['get', [0, path.parts]], expr);
        } else {
            var _path$parts2 = path.parts,
                head = _path$parts2[0],
                parts = _path$parts2.slice(1);

            this.opcode(['maybeGet', [head, parts]], expr);
        }
        // } else if (isLocal(path, this.symbols)) {
        //   let [head, ...parts] = path.parts;
        //   this.opcode(['get', [head, parts]], expr);
        // } else if (isSimplePath(path)) {
        //   this.opcode(['unknown', path.parts[0]], expr);
        // } else {
        //   this.opcode(['maybeLocal', path.parts], expr);
        // }
    };
    /// Internal Syntax


    TemplateCompiler.prototype.yield = function _yield(to, action) {
        this.prepareParams(action.params);
        this.opcode(['yield', to], action);
    };

    TemplateCompiler.prototype.debugger = function _debugger(_name, action) {
        this.opcode(['debugger', null], action);
    };

    TemplateCompiler.prototype.hasBlock = function hasBlock(name, action) {
        this.opcode(['hasBlock', name], action);
    };

    TemplateCompiler.prototype.hasBlockParams = function hasBlockParams(name, action) {
        this.opcode(['hasBlockParams', name], action);
    };

    TemplateCompiler.prototype.partial = function partial(_params, action) {
        this.prepareParams(action.params);
        this.opcode(['partial', null], action);
    };

    TemplateCompiler.prototype.builtInHelper = function builtInHelper(expr) {
        var path = expr.path;

        if (isHasBlock(path)) {
            var name = assertValidHasBlockUsage(expr.path.original, expr);
            this.hasBlock(name, expr);
        } else if (isHasBlockParams(path)) {
            var _name2 = assertValidHasBlockUsage(expr.path.original, expr);
            this.hasBlockParams(_name2, expr);
        }
    };
    /// Expressions, invoked recursively from prepareParams and prepareHash


    TemplateCompiler.prototype.SubExpression = function SubExpression(expr) {
        if (isBuiltInHelper(expr.path)) {
            this.builtInHelper(expr);
        } else {
            this.prepareHelper(expr);
            this.opcode(['helper', expr.path.parts[0]], expr);
        }
    };

    TemplateCompiler.prototype.PathExpression = function PathExpression(expr) {
        if (expr.data) {
            this.arg([expr]);
        } else {
            var _expr$parts = expr.parts,
                head = _expr$parts[0],
                rest = _expr$parts.slice(1);

            if (expr.this) {
                this.opcode(['get', [0, expr.parts]], expr);
            } else {
                this.opcode(['get', [head, rest]], expr);
            }
        }
    };

    TemplateCompiler.prototype.StringLiteral = function StringLiteral(action) {
        this.opcode(['literal', action.value], action);
    };

    TemplateCompiler.prototype.BooleanLiteral = function BooleanLiteral(action) {
        this.opcode(['literal', action.value], action);
    };

    TemplateCompiler.prototype.NumberLiteral = function NumberLiteral(action) {
        this.opcode(['literal', action.value], action);
    };

    TemplateCompiler.prototype.NullLiteral = function NullLiteral(action) {
        this.opcode(['literal', action.value], action);
    };

    TemplateCompiler.prototype.UndefinedLiteral = function UndefinedLiteral(action) {
        this.opcode(['literal', action.value], action);
    };
    /// Utilities


    TemplateCompiler.prototype.opcode = function opcode(_opcode) {
        var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // TODO: This doesn't really work
        if (this.includeMeta && action) {
            _opcode.push(this.meta(action));
        }
        this.opcodes.push(_opcode);
    };

    TemplateCompiler.prototype.prepareHelper = function prepareHelper(expr) {
        assertIsSimplePath(expr.path, expr.loc, 'helper');
        var params = expr.params,
            hash = expr.hash;

        this.prepareHash(hash);
        this.prepareParams(params);
    };

    TemplateCompiler.prototype.prepareParams = function prepareParams(params) {
        if (!params.length) {
            this.opcode(['literal', null], null);
            return;
        }
        for (var i = params.length - 1; i >= 0; i--) {
            var param = params[i];
            this[param.type](param);
        }
        this.opcode(['prepareArray', params.length], null);
    };

    TemplateCompiler.prototype.prepareHash = function prepareHash(hash) {
        var pairs = hash.pairs;
        if (!pairs.length) {
            this.opcode(['literal', null], null);
            return;
        }
        for (var i = pairs.length - 1; i >= 0; i--) {
            var _pairs$i = pairs[i],
                key = _pairs$i.key,
                value = _pairs$i.value;

            this[value.type](value);
            this.opcode(['literal', key], null);
        }
        this.opcode(['prepareObject', pairs.length], null);
    };

    TemplateCompiler.prototype.prepareAttributeValue = function prepareAttributeValue(value) {
        // returns the static value if the value is static
        switch (value.type) {
            case 'TextNode':
                this.opcode(['literal', value.chars], value);
                return true;
            case 'MustacheStatement':
                this.attributeMustache([value]);
                return false;
            case 'ConcatStatement':
                this.prepareConcatParts(value.parts);
                this.opcode(['concat', null], value);
                return false;
        }
    };

    TemplateCompiler.prototype.prepareConcatParts = function prepareConcatParts(parts) {
        for (var i = parts.length - 1; i >= 0; i--) {
            var part = parts[i];
            if (part.type === 'MustacheStatement') {
                this.attributeMustache([part]);
            } else if (part.type === 'TextNode') {
                this.opcode(['literal', part.chars], null);
            }
        }
        this.opcode(['prepareArray', parts.length], null);
    };

    TemplateCompiler.prototype.attributeMustache = function attributeMustache(_ref13) {
        var action = _ref13[0];

        this.mustacheExpression(action);
    };

    TemplateCompiler.prototype.meta = function meta(node) {
        var loc = node.loc;
        if (!loc) {
            return [];
        }
        var source = loc.source,
            start = loc.start,
            end = loc.end;

        return ['loc', [source || null, [start.line, start.column], [end.line, end.column]]];
    };

    return TemplateCompiler;
}();

function isHelperInvocation(mustache) {
    return mustache.params && mustache.params.length > 0 || mustache.hash && mustache.hash.pairs.length > 0;
}
function isSimplePath(_ref14) {
    var parts = _ref14.parts;

    return parts.length === 1;
}
function isYield(path) {
    return path.original === 'yield';
}
function isPartial(path) {
    return path.original === 'partial';
}
function isDebugger(path) {
    return path.original === 'debugger';
}
function isHasBlock(path) {
    return path.original === 'has-block';
}
function isHasBlockParams(path) {
    return path.original === 'has-block-params';
}
function isBuiltInHelper(path) {
    return isHasBlock(path) || isHasBlockParams(path);
}
function isArg(path) {
    return !!path['data'];
}
function isDynamicComponent(element) {
    var open = element.tag.charAt(0);

    var _element$tag$split = element.tag.split('.'),
        maybeLocal = _element$tag$split[0];

    var isNamedArgument = open === '@';
    var isLocal = element['symbols'].has(maybeLocal);
    var isThisPath = element.tag.indexOf('this.') === 0;
    return isLocal || isNamedArgument || isThisPath;
}
function isComponent(element) {
    var open = element.tag.charAt(0);
    var isPath = element.tag.indexOf('.') > -1;
    var isUpperCase = open === open.toUpperCase() && open !== open.toLowerCase();
    return isUpperCase && !isPath || isDynamicComponent(element);
}
function assertIsSimplePath(path, loc, context) {
    if (!isSimplePath(path)) {
        throw new syntax.SyntaxError('`' + path.original + '` is not a valid name for a ' + context + ' on line ' + loc.start.line + '.', path.loc);
    }
}
function assertValidYield(statement) {
    var pairs = statement.hash.pairs;

    if (pairs.length === 1 && pairs[0].key !== 'to' || pairs.length > 1) {
        throw new syntax.SyntaxError('yield only takes a single named argument: \'to\'', statement.loc);
    } else if (pairs.length === 1 && pairs[0].value.type !== 'StringLiteral') {
        throw new syntax.SyntaxError('you can only yield to a literal value', statement.loc);
    } else if (pairs.length === 0) {
        return 'default';
    } else {
        return pairs[0].value.value;
    }
}
function assertValidPartial(statement) {
    var params = statement.params,
        hash = statement.hash,
        escaped = statement.escaped,
        loc = statement.loc;

    if (params && params.length !== 1) {
        throw new syntax.SyntaxError('Partial found with no arguments. You must specify a template name. (on line ' + loc.start.line + ')', statement.loc);
    } else if (hash && hash.pairs.length > 0) {
        throw new syntax.SyntaxError('partial does not take any named arguments (on line ' + loc.start.line + ')', statement.loc);
    } else if (!escaped) {
        throw new syntax.SyntaxError('{{{partial ...}}} is not supported, please use {{partial ...}} instead (on line ' + loc.start.line + ')', statement.loc);
    }
    return params;
}
function assertValidHasBlockUsage(type, call) {
    var params = call.params,
        hash = call.hash,
        loc = call.loc;

    if (hash && hash.pairs.length > 0) {
        throw new syntax.SyntaxError(type + ' does not take any named arguments', call.loc);
    }
    if (params.length === 0) {
        return 'default';
    } else if (params.length === 1) {
        var param = params[0];
        if (param.type === 'StringLiteral') {
            return param.value;
        } else {
            throw new syntax.SyntaxError('you can only yield to a literal value (on line ' + loc.start.line + ')', call.loc);
        }
    } else {
        throw new syntax.SyntaxError(type + ' only takes a single positional argument (on line ' + loc.start.line + ')', call.loc);
    }
}
function assertValidDebuggerUsage(statement) {
    var params = statement.params,
        hash = statement.hash;

    if (hash && hash.pairs.length > 0) {
        throw new syntax.SyntaxError('debugger does not take any named arguments', statement.loc);
    }
    if (params.length === 0) {
        return 'default';
    } else {
        throw new syntax.SyntaxError('debugger does not take any positional arguments', statement.loc);
    }
}

var defaultId = function () {
    if (typeof require === 'function') {
        try {
            /* tslint:disable:no-require-imports */
            var crypto = require('crypto');
            /* tslint:enable:no-require-imports */
            var idFn = function idFn(src) {
                var hash = crypto.createHash('sha1');
                hash.update(src, 'utf8');
                // trim to 6 bytes of data (2^48 - 1)
                return hash.digest('base64').substring(0, 8);
            };
            idFn('test');
            return idFn;
        } catch (e) {}
    }
    return function idFn() {
        return null;
    };
}();
var defaultOptions = {
    id: defaultId,
    meta: {}
};
function precompile(string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;

    var ast = syntax.preprocess(string, options);
    var meta = options.meta;

    var _TemplateCompiler$com = TemplateCompiler.compile(ast, options),
        block = _TemplateCompiler$com.block;

    var idFn = options.id || defaultId;
    var blockJSON = JSON.stringify(block.toJSON());
    var templateJSONObject = {
        id: idFn(JSON.stringify(meta) + blockJSON),
        block: blockJSON,
        meta: meta
    };
    // JSON is javascript
    return JSON.stringify(templateJSONObject);
}

exports.defaultId = defaultId;
exports.precompile = precompile;
exports.TemplateCompiler = TemplateCompiler;
exports.TemplateVisitor = TemplateVisitor;

Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1jb21waWxlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvY29tcGlsZXIvbGliL3RlbXBsYXRlLXZpc2l0b3IudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9jb21waWxlci9saWIvamF2YXNjcmlwdC1jb21waWxlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi91dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9hbGxvY2F0ZS1zeW1ib2xzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvY29tcGlsZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvY29tcGlsZXIvbGliL2NvbXBpbGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFTVCB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgeyBDb3JlIH0gZnJvbSAnQGdsaW1tZXIvd2lyZS1mb3JtYXQnO1xuaW1wb3J0IHsgRGljdCwgT3B0aW9uLCBkaWN0LCB1bnJlYWNoYWJsZSwgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTeW1ib2xUYWJsZSB7XG4gIHN0YXRpYyB0b3AoKTogUHJvZ3JhbVN5bWJvbFRhYmxlIHtcbiAgICByZXR1cm4gbmV3IFByb2dyYW1TeW1ib2xUYWJsZSgpO1xuICB9XG5cbiAgYWJzdHJhY3QgaGFzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW47XG4gIGFic3RyYWN0IGdldChuYW1lOiBzdHJpbmcpOiBudW1iZXI7XG5cbiAgYWJzdHJhY3QgZ2V0TG9jYWxzTWFwKCk6IERpY3Q8bnVtYmVyPjtcbiAgYWJzdHJhY3QgZ2V0RXZhbEluZm8oKTogQ29yZS5FdmFsSW5mbztcblxuICBhYnN0cmFjdCBhbGxvY2F0ZU5hbWVkKG5hbWU6IHN0cmluZyk6IG51bWJlcjtcbiAgYWJzdHJhY3QgYWxsb2NhdGVCbG9jayhuYW1lOiBzdHJpbmcpOiBudW1iZXI7XG4gIGFic3RyYWN0IGFsbG9jYXRlKGlkZW50aWZpZXI6IHN0cmluZyk6IG51bWJlcjtcblxuICBjaGlsZChsb2NhbHM6IHN0cmluZ1tdKTogQmxvY2tTeW1ib2xUYWJsZSB7XG4gICAgbGV0IHN5bWJvbHMgPSBsb2NhbHMubWFwKG5hbWUgPT4gdGhpcy5hbGxvY2F0ZShuYW1lKSk7XG4gICAgcmV0dXJuIG5ldyBCbG9ja1N5bWJvbFRhYmxlKHRoaXMsIGxvY2Fscywgc3ltYm9scyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFByb2dyYW1TeW1ib2xUYWJsZSBleHRlbmRzIFN5bWJvbFRhYmxlIHtcbiAgcHVibGljIHN5bWJvbHM6IHN0cmluZ1tdID0gW107XG5cbiAgcHJpdmF0ZSBzaXplID0gMTtcbiAgcHJpdmF0ZSBuYW1lZCA9IGRpY3Q8bnVtYmVyPigpO1xuICBwcml2YXRlIGJsb2NrcyA9IGRpY3Q8bnVtYmVyPigpO1xuXG4gIGhhcyhfbmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0KF9uYW1lOiBzdHJpbmcpOiBuZXZlciB7XG4gICAgdGhyb3cgdW5yZWFjaGFibGUoKTtcbiAgfVxuXG4gIGdldExvY2Fsc01hcCgpOiBEaWN0PG51bWJlcj4ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGdldEV2YWxJbmZvKCk6IENvcmUuRXZhbEluZm8ge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGFsbG9jYXRlTmFtZWQobmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBsZXQgbmFtZWQgPSB0aGlzLm5hbWVkW25hbWVdO1xuXG4gICAgaWYgKCFuYW1lZCkge1xuICAgICAgbmFtZWQgPSB0aGlzLm5hbWVkW25hbWVdID0gdGhpcy5hbGxvY2F0ZShuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZWQ7XG4gIH1cblxuICBhbGxvY2F0ZUJsb2NrKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IGJsb2NrID0gdGhpcy5ibG9ja3NbbmFtZV07XG5cbiAgICBpZiAoIWJsb2NrKSB7XG4gICAgICBibG9jayA9IHRoaXMuYmxvY2tzW25hbWVdID0gdGhpcy5hbGxvY2F0ZShgJiR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cblxuICBhbGxvY2F0ZShpZGVudGlmaWVyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHRoaXMuc3ltYm9scy5wdXNoKGlkZW50aWZpZXIpO1xuICAgIHJldHVybiB0aGlzLnNpemUrKztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmxvY2tTeW1ib2xUYWJsZSBleHRlbmRzIFN5bWJvbFRhYmxlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJlbnQ6IFN5bWJvbFRhYmxlLCBwdWJsaWMgc3ltYm9sczogc3RyaW5nW10sIHB1YmxpYyBzbG90czogbnVtYmVyW10pIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgaGFzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN5bWJvbHMuaW5kZXhPZihuYW1lKSAhPT0gLTEgfHwgdGhpcy5wYXJlbnQuaGFzKG5hbWUpO1xuICB9XG5cbiAgZ2V0KG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IHNsb3QgPSB0aGlzLnN5bWJvbHMuaW5kZXhPZihuYW1lKTtcbiAgICByZXR1cm4gc2xvdCA9PT0gLTEgPyB0aGlzLnBhcmVudC5nZXQobmFtZSkgOiB0aGlzLnNsb3RzW3Nsb3RdO1xuICB9XG5cbiAgZ2V0TG9jYWxzTWFwKCk6IERpY3Q8bnVtYmVyPiB7XG4gICAgbGV0IGRpY3QgPSB0aGlzLnBhcmVudC5nZXRMb2NhbHNNYXAoKTtcbiAgICB0aGlzLnN5bWJvbHMuZm9yRWFjaChzeW1ib2wgPT4gKGRpY3Rbc3ltYm9sXSA9IHRoaXMuZ2V0KHN5bWJvbCkpKTtcbiAgICByZXR1cm4gZGljdDtcbiAgfVxuXG4gIGdldEV2YWxJbmZvKCk6IENvcmUuRXZhbEluZm8ge1xuICAgIGxldCBsb2NhbHMgPSB0aGlzLmdldExvY2Fsc01hcCgpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsb2NhbHMpLm1hcChzeW1ib2wgPT4gbG9jYWxzW3N5bWJvbF0pO1xuICB9XG5cbiAgYWxsb2NhdGVOYW1lZChuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hbGxvY2F0ZU5hbWVkKG5hbWUpO1xuICB9XG5cbiAgYWxsb2NhdGVCbG9jayhuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5hbGxvY2F0ZUJsb2NrKG5hbWUpO1xuICB9XG5cbiAgYWxsb2NhdGUoaWRlbnRpZmllcjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuYWxsb2NhdGUoaWRlbnRpZmllcik7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBpbiBhbiBBU1QgYW5kIG91dHB1dHMgYSBsaXN0IG9mIGFjdGlvbnMgdG8gYmUgY29uc3VtZWRcbiAqIGJ5IGEgY29tcGlsZXIuIEZvciBleGFtcGxlLCB0aGUgdGVtcGxhdGVcbiAqXG4gKiAgICAgZm9ve3tiYXJ9fTxkaXY+YmF6PC9kaXY+XG4gKlxuICogcHJvZHVjZXMgdGhlIGFjdGlvbnNcbiAqXG4gKiAgICAgW1snc3RhcnRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlLCAwXV0sXG4gKiAgICAgIFsndGV4dCcsIFt0ZXh0Tm9kZSwgMCwgM11dLFxuICogICAgICBbJ211c3RhY2hlJywgW211c3RhY2hlTm9kZSwgMSwgM11dLFxuICogICAgICBbJ29wZW5FbGVtZW50JywgW2VsZW1lbnROb2RlLCAyLCAzLCAwXV0sXG4gKiAgICAgIFsndGV4dCcsIFt0ZXh0Tm9kZSwgMCwgMV1dLFxuICogICAgICBbJ2Nsb3NlRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMiwgM10sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dXVxuICpcbiAqIFRoaXMgdmlzaXRvciB3YWxrcyB0aGUgQVNUIGRlcHRoIGZpcnN0IGFuZCBiYWNrd2FyZHMuIEFzXG4gKiBhIHJlc3VsdCB0aGUgYm90dG9tLW1vc3QgY2hpbGQgdGVtcGxhdGUgd2lsbCBhcHBlYXIgYXQgdGhlXG4gKiB0b3Agb2YgdGhlIGFjdGlvbnMgbGlzdCB3aGVyZWFzIHRoZSByb290IHRlbXBsYXRlIHdpbGwgYXBwZWFyXG4gKiBhdCB0aGUgYm90dG9tIG9mIHRoZSBsaXN0LiBGb3IgZXhhbXBsZSxcbiAqXG4gKiAgICAgPGRpdj57eyNpZn19Zm9ve3tlbHNlfX1iYXI8Yj48L2I+e3svaWZ9fTwvZGl2PlxuICpcbiAqIHByb2R1Y2VzIHRoZSBhY3Rpb25zXG4gKlxuICogICAgIFtbJ3N0YXJ0UHJvZ3JhbScsIFtwcm9ncmFtTm9kZSwgMF1dLFxuICogICAgICBbJ3RleHQnLCBbdGV4dE5vZGUsIDAsIDIsIDBdXSxcbiAqICAgICAgWydvcGVuRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMSwgMiwgMF1dLFxuICogICAgICBbJ2Nsb3NlRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMSwgMl1dLFxuICogICAgICBbJ2VuZFByb2dyYW0nLCBbcHJvZ3JhbU5vZGVdXSxcbiAqICAgICAgWydzdGFydFByb2dyYW0nLCBbcHJvZ3JhbU5vZGUsIDBdXSxcbiAqICAgICAgWyd0ZXh0JywgW3RleHROb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dLFxuICogICAgICBbJ3N0YXJ0UHJvZ3JhbScsIFtwcm9ncmFtTm9kZSwgMl1dLFxuICogICAgICBbJ29wZW5FbGVtZW50JywgW2VsZW1lbnROb2RlLCAwLCAxLCAxXV0sXG4gKiAgICAgIFsnYmxvY2snLCBbYmxvY2tOb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnY2xvc2VFbGVtZW50JywgW2VsZW1lbnROb2RlLCAwLCAxXV0sXG4gKiAgICAgIFsnZW5kUHJvZ3JhbScsIFtwcm9ncmFtTm9kZV1dXVxuICpcbiAqIFRoZSBzdGF0ZSBvZiB0aGUgdHJhdmVyc2FsIGlzIG1haW50YWluZWQgYnkgYSBzdGFjayBvZiBmcmFtZXMuXG4gKiBXaGVuZXZlciBhIG5vZGUgd2l0aCBjaGlsZHJlbiBpcyBlbnRlcmVkIChlaXRoZXIgYSBQcm9ncmFtTm9kZVxuICogb3IgYW4gRWxlbWVudE5vZGUpIGEgZnJhbWUgaXMgcHVzaGVkIG9udG8gdGhlIHN0YWNrLiBUaGUgZnJhbWVcbiAqIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdGF0ZSBvZiB0aGUgdHJhdmVyc2FsIG9mIHRoYXRcbiAqIG5vZGUuIEZvciBleGFtcGxlLFxuICpcbiAqICAgLSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGlsZCBub2RlIGJlaW5nIHZpc2l0ZWRcbiAqICAgLSB0aGUgbnVtYmVyIG9mIG11c3RhY2hlcyBjb250YWluZWQgd2l0aGluIGl0cyBjaGlsZCBub2Rlc1xuICogICAtIHRoZSBsaXN0IG9mIGFjdGlvbnMgZ2VuZXJhdGVkIGJ5IGl0cyBjaGlsZCBub2Rlc1xuICovXG5cbmNsYXNzIEZyYW1lIHtcbiAgcHVibGljIHBhcmVudE5vZGU6IE9wdGlvbjxPYmplY3Q+ID0gbnVsbDtcbiAgcHVibGljIGNoaWxkcmVuOiBPcHRpb248QVNULk5vZGVbXT4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRJbmRleDogT3B0aW9uPG51bWJlcj4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRDb3VudDogT3B0aW9uPG51bWJlcj4gPSBudWxsO1xuICBwdWJsaWMgY2hpbGRUZW1wbGF0ZUNvdW50ID0gMDtcbiAgcHVibGljIG11c3RhY2hlQ291bnQgPSAwO1xuICBwdWJsaWMgYWN0aW9uczogQWN0aW9uW10gPSBbXTtcbiAgcHVibGljIGJsYW5rQ2hpbGRUZXh0Tm9kZXM6IE9wdGlvbjxudW1iZXJbXT4gPSBudWxsO1xuICBwdWJsaWMgc3ltYm9sczogT3B0aW9uPFN5bWJvbFRhYmxlPiA9IG51bGw7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQWN0aW9uIHtcbiAgZXhwb3J0IHR5cGUgU3RhcnRQcm9ncmFtID0gWydzdGFydFByb2dyYW0nLCBbQVNULlByb2dyYW0sIG51bWJlciwgbnVtYmVyW11dXTtcbiAgZXhwb3J0IHR5cGUgRW5kUHJvZ3JhbSA9IFsnZW5kUHJvZ3JhbScsIFtBU1QuUHJvZ3JhbSwgbnVtYmVyXV07XG4gIGV4cG9ydCB0eXBlIFN0YXJ0QmxvY2sgPSBbJ3N0YXJ0QmxvY2snLCBbQVNULlByb2dyYW0sIG51bWJlciwgbnVtYmVyW11dXTtcbiAgZXhwb3J0IHR5cGUgRW5kQmxvY2sgPSBbJ2VuZEJsb2NrJywgW0FTVC5Qcm9ncmFtLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgQmxvY2sgPSBbJ2Jsb2NrJywgW0FTVC5CbG9ja1N0YXRlbWVudCwgbnVtYmVyLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgTXVzdGFjaGUgPSBbXG4gICAgJ211c3RhY2hlJyxcbiAgICBbQVNULk11c3RhY2hlU3RhdGVtZW50IHwgQVNULlBhcnRpYWxTdGF0ZW1lbnQsIG51bWJlciwgbnVtYmVyXVxuICBdO1xuICBleHBvcnQgdHlwZSBPcGVuRWxlbWVudCA9IFsnb3BlbkVsZW1lbnQnLCBbQVNULkVsZW1lbnROb2RlLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJbXV1dO1xuICBleHBvcnQgdHlwZSBDbG9zZUVsZW1lbnQgPSBbJ2Nsb3NlRWxlbWVudCcsIFtBU1QuRWxlbWVudE5vZGUsIG51bWJlciwgbnVtYmVyXV07XG4gIGV4cG9ydCB0eXBlIFRleHQgPSBbJ3RleHQnLCBbQVNULlRleHROb2RlLCBudW1iZXIsIG51bWJlcl1dO1xuICBleHBvcnQgdHlwZSBDb21tZW50ID0gWydjb21tZW50JywgW0FTVC5Db21tZW50U3RhdGVtZW50LCBudW1iZXIsIG51bWJlcl1dO1xuXG4gIGV4cG9ydCB0eXBlIEFjdGlvbiA9XG4gICAgfCBTdGFydFByb2dyYW1cbiAgICB8IEVuZFByb2dyYW1cbiAgICB8IFN0YXJ0QmxvY2tcbiAgICB8IEVuZEJsb2NrXG4gICAgfCBCbG9ja1xuICAgIHwgTXVzdGFjaGVcbiAgICB8IE9wZW5FbGVtZW50XG4gICAgfCBDbG9zZUVsZW1lbnRcbiAgICB8IFRleHRcbiAgICB8IENvbW1lbnQ7XG59XG5cbmV4cG9ydCB0eXBlIEFjdGlvbiA9IEFjdGlvbi5BY3Rpb247XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlVmlzaXRvciB7XG4gIHByaXZhdGUgZnJhbWVTdGFjazogRnJhbWVbXSA9IFtdO1xuICBwdWJsaWMgYWN0aW9uczogQWN0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBwcm9ncmFtRGVwdGggPSAtMTtcblxuICB2aXNpdChub2RlOiBBU1QuQmFzZU5vZGUpIHtcbiAgICB0aGlzW25vZGUudHlwZV0obm9kZSk7XG4gIH1cblxuICAvLyBUcmF2ZXJzYWwgbWV0aG9kc1xuXG4gIFByb2dyYW0ocHJvZ3JhbTogQVNULlByb2dyYW0pIHtcbiAgICB0aGlzLnByb2dyYW1EZXB0aCsrO1xuXG4gICAgbGV0IHBhcmVudEZyYW1lID0gdGhpcy5nZXRDdXJyZW50RnJhbWUoKTtcbiAgICBsZXQgcHJvZ3JhbUZyYW1lID0gdGhpcy5wdXNoRnJhbWUoKTtcblxuICAgIGlmICghcGFyZW50RnJhbWUpIHtcbiAgICAgIHByb2dyYW1bJ3N5bWJvbHMnXSA9IFN5bWJvbFRhYmxlLnRvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9ncmFtWydzeW1ib2xzJ10gPSBwYXJlbnRGcmFtZS5zeW1ib2xzIS5jaGlsZChwcm9ncmFtLmJsb2NrUGFyYW1zKTtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnRUeXBlOiBzdHJpbmcsIGVuZFR5cGU6IHN0cmluZztcblxuICAgIGlmICh0aGlzLnByb2dyYW1EZXB0aCA9PT0gMCkge1xuICAgICAgc3RhcnRUeXBlID0gJ3N0YXJ0UHJvZ3JhbSc7XG4gICAgICBlbmRUeXBlID0gJ2VuZFByb2dyYW0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFR5cGUgPSAnc3RhcnRCbG9jayc7XG4gICAgICBlbmRUeXBlID0gJ2VuZEJsb2NrJztcbiAgICB9XG5cbiAgICBwcm9ncmFtRnJhbWUucGFyZW50Tm9kZSA9IHByb2dyYW07XG4gICAgcHJvZ3JhbUZyYW1lLmNoaWxkcmVuID0gcHJvZ3JhbS5ib2R5O1xuICAgIHByb2dyYW1GcmFtZS5jaGlsZENvdW50ID0gcHJvZ3JhbS5ib2R5Lmxlbmd0aDtcbiAgICBwcm9ncmFtRnJhbWUuYmxhbmtDaGlsZFRleHROb2RlcyA9IFtdO1xuICAgIHByb2dyYW1GcmFtZS5hY3Rpb25zLnB1c2goW2VuZFR5cGUsIFtwcm9ncmFtLCB0aGlzLnByb2dyYW1EZXB0aF1dIGFzIEFjdGlvbik7XG4gICAgcHJvZ3JhbUZyYW1lLnN5bWJvbHMgPSBwcm9ncmFtWydzeW1ib2xzJ107XG5cbiAgICBmb3IgKGxldCBpID0gcHJvZ3JhbS5ib2R5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBwcm9ncmFtRnJhbWUuY2hpbGRJbmRleCA9IGk7XG4gICAgICB0aGlzLnZpc2l0KHByb2dyYW0uYm9keVtpXSk7XG4gICAgfVxuXG4gICAgcHJvZ3JhbUZyYW1lLmFjdGlvbnMucHVzaChbXG4gICAgICBzdGFydFR5cGUsXG4gICAgICBbcHJvZ3JhbSwgcHJvZ3JhbUZyYW1lLmNoaWxkVGVtcGxhdGVDb3VudCwgcHJvZ3JhbUZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMucmV2ZXJzZSgpXSxcbiAgICBdIGFzIEFjdGlvbik7XG4gICAgdGhpcy5wb3BGcmFtZSgpO1xuXG4gICAgdGhpcy5wcm9ncmFtRGVwdGgtLTtcblxuICAgIC8vIFB1c2ggdGhlIGNvbXBsZXRlZCB0ZW1wbGF0ZSBpbnRvIHRoZSBnbG9iYWwgYWN0aW9ucyBsaXN0XG4gICAgaWYgKHBhcmVudEZyYW1lKSB7XG4gICAgICBwYXJlbnRGcmFtZS5jaGlsZFRlbXBsYXRlQ291bnQrKztcbiAgICB9XG4gICAgdGhpcy5hY3Rpb25zLnB1c2goLi4ucHJvZ3JhbUZyYW1lLmFjdGlvbnMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIEVsZW1lbnROb2RlKGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIGxldCBwYXJlbnRGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGxldCBlbGVtZW50RnJhbWUgPSB0aGlzLnB1c2hGcmFtZSgpO1xuXG4gICAgZWxlbWVudEZyYW1lLnBhcmVudE5vZGUgPSBlbGVtZW50O1xuICAgIGVsZW1lbnRGcmFtZS5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgZWxlbWVudEZyYW1lLmNoaWxkQ291bnQgPSBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICBlbGVtZW50RnJhbWUubXVzdGFjaGVDb3VudCArPSBlbGVtZW50Lm1vZGlmaWVycy5sZW5ndGg7XG4gICAgZWxlbWVudEZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMgPSBbXTtcbiAgICBlbGVtZW50RnJhbWUuc3ltYm9scyA9IGVsZW1lbnRbJ3N5bWJvbHMnXSA9IHBhcmVudEZyYW1lLnN5bWJvbHMhLmNoaWxkKGVsZW1lbnQuYmxvY2tQYXJhbXMpO1xuXG4gICAgbGV0IGFjdGlvbkFyZ3M6IFtBU1QuRWxlbWVudE5vZGUsIG51bWJlciwgbnVtYmVyXSA9IFtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYXJlbnRGcmFtZS5jaGlsZEluZGV4ISxcbiAgICAgIHBhcmVudEZyYW1lLmNoaWxkQ291bnQhLFxuICAgIF07XG5cbiAgICBlbGVtZW50RnJhbWUuYWN0aW9ucy5wdXNoKFsnY2xvc2VFbGVtZW50JywgYWN0aW9uQXJnc10pO1xuXG4gICAgZm9yIChsZXQgaSA9IGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy52aXNpdChlbGVtZW50LmF0dHJpYnV0ZXNbaV0pO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBlbGVtZW50RnJhbWUuY2hpbGRJbmRleCA9IGk7XG4gICAgICB0aGlzLnZpc2l0KGVsZW1lbnQuY2hpbGRyZW5baV0pO1xuICAgIH1cblxuICAgIGxldCBvcGVuID0gW1xuICAgICAgJ29wZW5FbGVtZW50JyxcbiAgICAgIFsuLi5hY3Rpb25BcmdzLCBlbGVtZW50RnJhbWUubXVzdGFjaGVDb3VudCwgZWxlbWVudEZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMucmV2ZXJzZSgpXSxcbiAgICBdIGFzIEFjdGlvbi5PcGVuRWxlbWVudDtcbiAgICBlbGVtZW50RnJhbWUuYWN0aW9ucy5wdXNoKG9wZW4pO1xuXG4gICAgdGhpcy5wb3BGcmFtZSgpO1xuXG4gICAgLy8gUHJvcGFnYXRlIHRoZSBlbGVtZW50J3MgZnJhbWUgc3RhdGUgdG8gdGhlIHBhcmVudCBmcmFtZVxuICAgIGlmIChlbGVtZW50RnJhbWUubXVzdGFjaGVDb3VudCA+IDApIHtcbiAgICAgIHBhcmVudEZyYW1lLm11c3RhY2hlQ291bnQrKztcbiAgICB9XG4gICAgcGFyZW50RnJhbWUuY2hpbGRUZW1wbGF0ZUNvdW50ICs9IGVsZW1lbnRGcmFtZS5jaGlsZFRlbXBsYXRlQ291bnQ7XG4gICAgcGFyZW50RnJhbWUuYWN0aW9ucy5wdXNoKC4uLmVsZW1lbnRGcmFtZS5hY3Rpb25zKTtcbiAgfVxuXG4gIEF0dHJOb2RlKGF0dHI6IEFTVC5BdHRyTm9kZSkge1xuICAgIGlmIChhdHRyLnZhbHVlLnR5cGUgIT09ICdUZXh0Tm9kZScpIHtcbiAgICAgIHRoaXMuY3VycmVudEZyYW1lLm11c3RhY2hlQ291bnQrKztcbiAgICB9XG4gIH1cblxuICBUZXh0Tm9kZSh0ZXh0OiBBU1QuVGV4dE5vZGUpIHtcbiAgICBsZXQgZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICBpZiAodGV4dC5jaGFycyA9PT0gJycpIHtcbiAgICAgIGZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMhLnB1c2goZG9tSW5kZXhPZihmcmFtZS5jaGlsZHJlbiEsIHRleHQpKTtcbiAgICB9XG4gICAgZnJhbWUuYWN0aW9ucy5wdXNoKFsndGV4dCcsIFt0ZXh0LCBmcmFtZS5jaGlsZEluZGV4LCBmcmFtZS5jaGlsZENvdW50XV0gYXMgQWN0aW9uKTtcbiAgfVxuXG4gIEJsb2NrU3RhdGVtZW50KG5vZGU6IEFTVC5CbG9ja1N0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuXG4gICAgZnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIGZyYW1lLmFjdGlvbnMucHVzaChbJ2Jsb2NrJywgW25vZGUsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuXG4gICAgaWYgKG5vZGUuaW52ZXJzZSkge1xuICAgICAgdGhpcy52aXNpdChub2RlLmludmVyc2UpO1xuICAgIH1cbiAgICBpZiAobm9kZS5wcm9ncmFtKSB7XG4gICAgICB0aGlzLnZpc2l0KG5vZGUucHJvZ3JhbSk7XG4gICAgfVxuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChub2RlOiBBU1QuUGFydGlhbFN0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGZyYW1lLm11c3RhY2hlQ291bnQrKztcbiAgICBmcmFtZS5hY3Rpb25zLnB1c2goWydtdXN0YWNoZScsIFtub2RlLCBmcmFtZS5jaGlsZEluZGV4LCBmcmFtZS5jaGlsZENvdW50XV0gYXMgQWN0aW9uKTtcbiAgfVxuXG4gIENvbW1lbnRTdGF0ZW1lbnQodGV4dDogQVNULkNvbW1lbnRTdGF0ZW1lbnQpIHtcbiAgICBsZXQgZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICBmcmFtZS5hY3Rpb25zLnB1c2goWydjb21tZW50JywgW3RleHQsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuICB9XG5cbiAgTXVzdGFjaGVDb21tZW50U3RhdGVtZW50KCkge1xuICAgIC8vIEludGVudGlvbmFsIGVtcHR5OiBIYW5kbGViYXJzIGNvbW1lbnRzIHNob3VsZCBub3QgYWZmZWN0IG91dHB1dC5cbiAgfVxuXG4gIE11c3RhY2hlU3RhdGVtZW50KG11c3RhY2hlOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgICBsZXQgZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICBmcmFtZS5tdXN0YWNoZUNvdW50Kys7XG4gICAgZnJhbWUuYWN0aW9ucy5wdXNoKFsnbXVzdGFjaGUnLCBbbXVzdGFjaGUsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuICB9XG5cbiAgLy8gRnJhbWUgaGVscGVyc1xuXG4gIHByaXZhdGUgZ2V0IGN1cnJlbnRGcmFtZSgpOiBGcmFtZSB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLmdldEN1cnJlbnRGcmFtZSgpLCAnRXhwZWN0ZWQgYSBjdXJyZW50IGZyYW1lJyk7XG4gIH1cblxuICBwcml2YXRlIGdldEN1cnJlbnRGcmFtZSgpOiBPcHRpb248RnJhbWU+IHtcbiAgICByZXR1cm4gdGhpcy5mcmFtZVN0YWNrW3RoaXMuZnJhbWVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHByaXZhdGUgcHVzaEZyYW1lKCkge1xuICAgIGxldCBmcmFtZSA9IG5ldyBGcmFtZSgpO1xuICAgIHRoaXMuZnJhbWVTdGFjay5wdXNoKGZyYW1lKTtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICBwcml2YXRlIHBvcEZyYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmZyYW1lU3RhY2sucG9wKCk7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgYGRvbU5vZGVgIGluIHRoZSBgbm9kZXNgIGFycmF5LCBza2lwcGluZ1xuLy8gb3ZlciBhbnkgbm9kZXMgd2hpY2ggZG8gbm90IHJlcHJlc2VudCBET00gbm9kZXMuXG5mdW5jdGlvbiBkb21JbmRleE9mKG5vZGVzOiBBU1QuTm9kZVtdLCBkb21Ob2RlOiBBU1QuVGV4dE5vZGUgfCBBU1QuRWxlbWVudE5vZGUpIHtcbiAgbGV0IGluZGV4ID0gLTE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAobm9kZS50eXBlICE9PSAnVGV4dE5vZGUnICYmIG5vZGUudHlwZSAhPT0gJ0VsZW1lbnROb2RlJykge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGRvbU5vZGUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG4iLCJpbXBvcnQgeyBhc3NlcnQgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFN0YWNrLCBEaWN0U2V0LCBPcHRpb24sIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVNUIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IEJsb2NrU3ltYm9sVGFibGUsIFByb2dyYW1TeW1ib2xUYWJsZSB9IGZyb20gJy4vdGVtcGxhdGUtdmlzaXRvcic7XG5pbXBvcnQgeyBDb21waWxlT3B0aW9ucyB9IGZyb20gJy4vdGVtcGxhdGUtY29tcGlsZXInO1xuaW1wb3J0IHtcbiAgU2VyaWFsaXplZElubGluZUJsb2NrLFxuICBTZXJpYWxpemVkVGVtcGxhdGVCbG9jayxcbiAgQ29yZSxcbiAgU3RhdGVtZW50LFxuICBTdGF0ZW1lbnRzLFxuICBFeHByZXNzaW9uLFxuICBFeHByZXNzaW9ucyxcbiAgT3BzLFxuICBpc0ZsdXNoRWxlbWVudCxcbiAgaXNBcmd1bWVudCxcbiAgaXNBdHRyaWJ1dGUsXG4gIGlzQXR0clNwbGF0LFxufSBmcm9tICdAZ2xpbW1lci93aXJlLWZvcm1hdCc7XG5pbXBvcnQgeyBQcm9jZXNzb3IsIENvbXBpbGVyT3BzLCBPcE5hbWUsIE9wIH0gZnJvbSAnLi9jb21waWxlci1vcHMnO1xuXG5leHBvcnQgdHlwZSBzdHIgPSBzdHJpbmc7XG5leHBvcnQgdHlwZSBQYXJhbXMgPSBDb3JlLlBhcmFtcztcbmV4cG9ydCB0eXBlIEhhc2ggPSBDb3JlLkhhc2g7XG5leHBvcnQgdHlwZSBQYXRoID0gQ29yZS5QYXRoO1xuZXhwb3J0IHR5cGUgU3RhY2tWYWx1ZSA9IEV4cHJlc3Npb24gfCBQYXJhbXMgfCBIYXNoIHwgc3RyO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmxvY2sge1xuICBwdWJsaWMgc3RhdGVtZW50czogU3RhdGVtZW50W10gPSBbXTtcblxuICBhYnN0cmFjdCB0b0pTT04oKTogT2JqZWN0O1xuXG4gIHB1c2goc3RhdGVtZW50OiBTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnN0YXRlbWVudHMucHVzaChzdGF0ZW1lbnQpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbmxpbmVCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgY29uc3RydWN0b3IocHVibGljIHRhYmxlOiBCbG9ja1N5bWJvbFRhYmxlKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBTZXJpYWxpemVkSW5saW5lQmxvY2sge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0ZW1lbnRzOiB0aGlzLnN0YXRlbWVudHMsXG4gICAgICBwYXJhbWV0ZXJzOiB0aGlzLnRhYmxlLnNsb3RzLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlQmxvY2sgZXh0ZW5kcyBCbG9jayB7XG4gIHB1YmxpYyB0eXBlID0gJ3RlbXBsYXRlJztcbiAgcHVibGljIHlpZWxkcyA9IG5ldyBEaWN0U2V0PHN0cmluZz4oKTtcbiAgcHVibGljIG5hbWVkID0gbmV3IERpY3RTZXQ8c3RyaW5nPigpO1xuICBwdWJsaWMgYmxvY2tzOiBTZXJpYWxpemVkSW5saW5lQmxvY2tbXSA9IFtdO1xuICBwdWJsaWMgaGFzRXZhbCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3ltYm9sVGFibGU6IFByb2dyYW1TeW1ib2xUYWJsZSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdXNoKHN0YXRlbWVudDogU3RhdGVtZW50KSB7XG4gICAgdGhpcy5zdGF0ZW1lbnRzLnB1c2goc3RhdGVtZW50KTtcbiAgfVxuXG4gIHRvSlNPTigpOiBTZXJpYWxpemVkVGVtcGxhdGVCbG9jayB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN5bWJvbHM6IHRoaXMuc3ltYm9sVGFibGUuc3ltYm9scyxcbiAgICAgIHN0YXRlbWVudHM6IHRoaXMuc3RhdGVtZW50cyxcbiAgICAgIGhhc0V2YWw6IHRoaXMuaGFzRXZhbCxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgcHVibGljIGF0dHJpYnV0ZXM6IFN0YXRlbWVudHMuQXR0cmlidXRlW10gPSBbXTtcbiAgcHVibGljIGFyZ3VtZW50czogU3RhdGVtZW50cy5Bcmd1bWVudFtdID0gW107XG4gIHByaXZhdGUgaW5QYXJhbXMgPSB0cnVlO1xuICBwdWJsaWMgcG9zaXRpb25hbHM6IG51bWJlcltdID0gW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0YWc6IHN0cmluZywgcHJpdmF0ZSB0YWJsZTogQmxvY2tTeW1ib2xUYWJsZSwgcHJpdmF0ZSBzZWxmQ2xvc2luZzogYm9vbGVhbikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdXNoKHN0YXRlbWVudDogU3RhdGVtZW50KSB7XG4gICAgaWYgKHRoaXMuaW5QYXJhbXMpIHtcbiAgICAgIGlmIChpc0ZsdXNoRWxlbWVudChzdGF0ZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuaW5QYXJhbXMgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcmd1bWVudChzdGF0ZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuYXJndW1lbnRzLnB1c2goc3RhdGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBdHRyaWJ1dGUoc3RhdGVtZW50KSkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0F0dHJTcGxhdChzdGF0ZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHN0YXRlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBpbGUgRXJyb3I6IG9ubHkgcGFyYW1ldGVycyBhbGxvd2VkIGJlZm9yZSBmbHVzaC1lbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCk6IFtzdHJpbmcsIFN0YXRlbWVudHMuQXR0cmlidXRlW10sIENvcmUuSGFzaCwgT3B0aW9uPFNlcmlhbGl6ZWRJbmxpbmVCbG9jaz5dIHtcbiAgICBsZXQgYXJncyA9IHRoaXMuYXJndW1lbnRzO1xuICAgIGxldCBrZXlzID0gYXJncy5tYXAoYXJnID0+IGFyZ1sxXSk7XG4gICAgbGV0IHZhbHVlcyA9IGFyZ3MubWFwKGFyZyA9PiBhcmdbMl0pO1xuICAgIGxldCBibG9jayA9IHRoaXMuc2VsZkNsb3NpbmdcbiAgICAgID8gbnVsbFxuICAgICAgOiB7XG4gICAgICAgICAgc3RhdGVtZW50czogdGhpcy5zdGF0ZW1lbnRzLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHRoaXMudGFibGUuc2xvdHMsXG4gICAgICAgIH07XG5cbiAgICByZXR1cm4gW3RoaXMudGFnLCB0aGlzLmF0dHJpYnV0ZXMsIFtrZXlzLCB2YWx1ZXNdLCBibG9ja107XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlIHtcbiAgcHVibGljIGJsb2NrOiBUZW1wbGF0ZUJsb2NrO1xuXG4gIGNvbnN0cnVjdG9yKHN5bWJvbHM6IFByb2dyYW1TeW1ib2xUYWJsZSkge1xuICAgIHRoaXMuYmxvY2sgPSBuZXcgVGVtcGxhdGVCbG9jayhzeW1ib2xzKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBTZXJpYWxpemVkVGVtcGxhdGVCbG9jayB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2sudG9KU09OKCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgSW5WYXJpYWJsZSA9IG51bWJlcjtcbmV4cG9ydCB0eXBlIEluT3A8SyBleHRlbmRzIGtleW9mIENvbXBpbGVyT3BzPEluVmFyaWFibGU+ID0gT3BOYW1lPiA9IE9wPFxuICBJblZhcmlhYmxlLFxuICBDb21waWxlck9wczxJblZhcmlhYmxlPixcbiAgS1xuPjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSmF2YVNjcmlwdENvbXBpbGVyXG4gIGltcGxlbWVudHMgUHJvY2Vzc29yPENvbXBpbGVyT3BzPG51bWJlcj4sIHZvaWQsIENvbXBpbGVyT3BzPHZvaWQ+PiB7XG4gIHN0YXRpYyBwcm9jZXNzKG9wY29kZXM6IEluT3BbXSwgc3ltYm9sczogUHJvZ3JhbVN5bWJvbFRhYmxlLCBvcHRpb25zPzogQ29tcGlsZU9wdGlvbnMpOiBUZW1wbGF0ZSB7XG4gICAgbGV0IGNvbXBpbGVyID0gbmV3IEphdmFTY3JpcHRDb21waWxlcihvcGNvZGVzLCBzeW1ib2xzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29tcGlsZXIucHJvY2VzcygpO1xuICB9XG5cbiAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGU7XG4gIHByaXZhdGUgYmxvY2tzID0gbmV3IFN0YWNrPEJsb2NrPigpO1xuICBwcml2YXRlIG9wY29kZXM6IEluT3BbXTtcbiAgcHJpdmF0ZSB2YWx1ZXM6IFN0YWNrVmFsdWVbXSA9IFtdO1xuICBwcml2YXRlIG9wdGlvbnM6IENvbXBpbGVPcHRpb25zIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKG9wY29kZXM6IEluT3BbXSwgc3ltYm9sczogUHJvZ3JhbVN5bWJvbFRhYmxlLCBvcHRpb25zPzogQ29tcGlsZU9wdGlvbnMpIHtcbiAgICB0aGlzLm9wY29kZXMgPSBvcGNvZGVzO1xuICAgIHRoaXMudGVtcGxhdGUgPSBuZXcgVGVtcGxhdGUoc3ltYm9scyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCBjdXJyZW50QmxvY2soKTogQmxvY2sge1xuICAgIHJldHVybiBleHBlY3QodGhpcy5ibG9ja3MuY3VycmVudCwgJ0V4cGVjdGVkIGEgYmxvY2sgb24gdGhlIHN0YWNrJyk7XG4gIH1cblxuICBwcm9jZXNzKCk6IFRlbXBsYXRlIHtcbiAgICB0aGlzLm9wY29kZXMuZm9yRWFjaChvcCA9PiB7XG4gICAgICBsZXQgb3Bjb2RlID0gb3BbMF07XG4gICAgICBsZXQgYXJnID0gb3BbMV07XG5cbiAgICAgIGlmICghdGhpc1tvcGNvZGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5pbXBsZW1lbnRlZCAke29wY29kZX0gb24gSmF2YVNjcmlwdENvbXBpbGVyYCk7XG4gICAgICB9XG4gICAgICAodGhpc1tvcGNvZGVdIGFzIGFueSkoYXJnKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlO1xuICB9XG5cbiAgLy8vIE5lc3RpbmdcblxuICBzdGFydEJsb2NrKHByb2dyYW06IEFTVC5Qcm9ncmFtKSB7XG4gICAgbGV0IGJsb2NrOiBCbG9jayA9IG5ldyBJbmxpbmVCbG9jayhwcm9ncmFtWydzeW1ib2xzJ10pO1xuICAgIHRoaXMuYmxvY2tzLnB1c2goYmxvY2spO1xuICB9XG5cbiAgZW5kQmxvY2soKSB7XG4gICAgbGV0IHsgdGVtcGxhdGUsIGJsb2NrcyB9ID0gdGhpcztcbiAgICBsZXQgYmxvY2sgPSBibG9ja3MucG9wKCkgYXMgSW5saW5lQmxvY2s7XG4gICAgdGVtcGxhdGUuYmxvY2suYmxvY2tzLnB1c2goYmxvY2sudG9KU09OKCkpO1xuICB9XG5cbiAgc3RhcnRQcm9ncmFtKCkge1xuICAgIHRoaXMuYmxvY2tzLnB1c2godGhpcy50ZW1wbGF0ZS5ibG9jayk7XG4gIH1cblxuICBlbmRQcm9ncmFtKCkge31cblxuICAvLy8gU3RhdGVtZW50c1xuXG4gIHRleHQoY29udGVudDogc3RyaW5nKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuVGV4dCwgY29udGVudF0pO1xuICB9XG5cbiAgYXBwZW5kKHRydXN0ZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnB1c2goW09wcy5BcHBlbmQsIHRoaXMucG9wVmFsdWU8RXhwcmVzc2lvbj4oKSwgdHJ1c3RlZF0pO1xuICB9XG5cbiAgY29tbWVudCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuQ29tbWVudCwgdmFsdWVdKTtcbiAgfVxuXG4gIG1vZGlmaWVyKG5hbWU6IHN0cmluZykge1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLnBvcFZhbHVlPFBhcmFtcz4oKTtcbiAgICBsZXQgaGFzaCA9IHRoaXMucG9wVmFsdWU8SGFzaD4oKTtcblxuICAgIHRoaXMucHVzaChbT3BzLk1vZGlmaWVyLCBuYW1lLCBwYXJhbXMsIGhhc2hdKTtcbiAgfVxuXG4gIGJsb2NrKFtuYW1lLCB0ZW1wbGF0ZSwgaW52ZXJzZV06IFtzdHJpbmcsIG51bWJlciwgT3B0aW9uPG51bWJlcj5dKSB7XG4gICAgbGV0IHBhcmFtcyA9IHRoaXMucG9wVmFsdWU8UGFyYW1zPigpO1xuICAgIGxldCBoYXNoID0gdGhpcy5wb3BWYWx1ZTxIYXNoPigpO1xuXG4gICAgbGV0IGJsb2NrcyA9IHRoaXMudGVtcGxhdGUuYmxvY2suYmxvY2tzO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ251bWJlcicgfHwgYmxvY2tzW3RlbXBsYXRlXSAhPT0gbnVsbCxcbiAgICAgICdtaXNzaW5nIGJsb2NrIGluIHRoZSBjb21waWxlcidcbiAgICApO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiBpbnZlcnNlICE9PSAnbnVtYmVyJyB8fCBibG9ja3NbaW52ZXJzZV0gIT09IG51bGwsXG4gICAgICAnbWlzc2luZyBibG9jayBpbiB0aGUgY29tcGlsZXInXG4gICAgKTtcblxuICAgIHRoaXMucHVzaChbT3BzLkJsb2NrLCBuYW1lLCBwYXJhbXMsIGhhc2gsIGJsb2Nrc1t0ZW1wbGF0ZV0sIGJsb2Nrc1tpbnZlcnNlIV1dKTtcbiAgfVxuXG4gIG9wZW5Db21wb25lbnQoZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgbGV0IHRhZyA9XG4gICAgICB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmN1c3RvbWl6ZUNvbXBvbmVudE5hbWVcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuY3VzdG9taXplQ29tcG9uZW50TmFtZShlbGVtZW50LnRhZylcbiAgICAgICAgOiBlbGVtZW50LnRhZztcbiAgICBsZXQgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudEJsb2NrKHRhZywgZWxlbWVudFsnc3ltYm9scyddLCBlbGVtZW50LnNlbGZDbG9zaW5nKTtcbiAgICB0aGlzLmJsb2Nrcy5wdXNoKGNvbXBvbmVudCk7XG4gIH1cblxuICBvcGVuU3BsYXR0ZWRFbGVtZW50KGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIGxldCB0YWcgPSBlbGVtZW50LnRhZztcblxuICAgIGlmIChlbGVtZW50LmJsb2NrUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvbXBpbGUgRXJyb3I6IDwke2VsZW1lbnQudGFnfT4gaXMgbm90IGEgY29tcG9uZW50IGFuZCBkb2Vzbid0IHN1cHBvcnQgYmxvY2sgcGFyYW1ldGVyc2BcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaChbT3BzLk9wZW5TcGxhdHRlZEVsZW1lbnQsIHRhZ10pO1xuICAgIH1cbiAgfVxuXG4gIG9wZW5FbGVtZW50KGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIGxldCB0YWcgPSBlbGVtZW50LnRhZztcblxuICAgIGlmIChlbGVtZW50LmJsb2NrUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvbXBpbGUgRXJyb3I6IDwke2VsZW1lbnQudGFnfT4gaXMgbm90IGEgY29tcG9uZW50IGFuZCBkb2Vzbid0IHN1cHBvcnQgYmxvY2sgcGFyYW1ldGVyc2BcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaChbT3BzLk9wZW5FbGVtZW50LCB0YWddKTtcbiAgICB9XG4gIH1cblxuICBmbHVzaEVsZW1lbnQoKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuRmx1c2hFbGVtZW50XSk7XG4gIH1cblxuICBjbG9zZUNvbXBvbmVudChfZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgaWYgKF9lbGVtZW50Lm1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBpbGUgRXJyb3I6IEVsZW1lbnQgbW9kaWZpZXJzIGFyZSBub3QgYWxsb3dlZCBpbiBjb21wb25lbnRzJyk7XG4gICAgfVxuICAgIGxldCBbdGFnLCBhdHRycywgYXJncywgYmxvY2tdID0gdGhpcy5lbmRDb21wb25lbnQoKTtcblxuICAgIHRoaXMucHVzaChbT3BzLkNvbXBvbmVudCwgdGFnLCBhdHRycywgYXJncywgYmxvY2tdKTtcbiAgfVxuXG4gIGNsb3NlRHluYW1pY0NvbXBvbmVudChfZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgbGV0IFssIGF0dHJzLCBhcmdzLCBibG9ja10gPSB0aGlzLmVuZENvbXBvbmVudCgpO1xuXG4gICAgdGhpcy5wdXNoKFtPcHMuRHluYW1pY0NvbXBvbmVudCwgdGhpcy5wb3BWYWx1ZTxFeHByZXNzaW9uPigpLCBhdHRycywgYXJncywgYmxvY2tdKTtcbiAgfVxuXG4gIGNsb3NlRWxlbWVudChfZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuQ2xvc2VFbGVtZW50XSk7XG4gIH1cblxuICBzdGF0aWNBdHRyKFtuYW1lLCBuYW1lc3BhY2VdOiBbc3RyaW5nLCBPcHRpb248c3RyaW5nPl0pIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnBvcFZhbHVlPEV4cHJlc3Npb24+KCk7XG4gICAgdGhpcy5wdXNoKFtPcHMuU3RhdGljQXR0ciwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZV0pO1xuICB9XG5cbiAgZHluYW1pY0F0dHIoW25hbWUsIG5hbWVzcGFjZV06IFtzdHJpbmcsIE9wdGlvbjxzdHJpbmc+XSkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMucG9wVmFsdWU8RXhwcmVzc2lvbj4oKTtcbiAgICB0aGlzLnB1c2goW09wcy5EeW5hbWljQXR0ciwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZV0pO1xuICB9XG5cbiAgdHJ1c3RpbmdBdHRyKFtuYW1lLCBuYW1lc3BhY2VdOiBbc3RyaW5nLCBPcHRpb248c3RyaW5nPl0pIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnBvcFZhbHVlPEV4cHJlc3Npb24+KCk7XG4gICAgdGhpcy5wdXNoKFtPcHMuVHJ1c3RpbmdBdHRyLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlIV0pO1xuICB9XG5cbiAgc3RhdGljQXJnKG5hbWU6IHN0cikge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMucG9wVmFsdWU8RXhwcmVzc2lvbj4oKTtcbiAgICB0aGlzLnB1c2goW09wcy5TdGF0aWNBcmcsIG5hbWUsIHZhbHVlXSk7XG4gIH1cblxuICBkeW5hbWljQXJnKG5hbWU6IHN0cikge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMucG9wVmFsdWU8RXhwcmVzc2lvbj4oKTtcbiAgICB0aGlzLnB1c2goW09wcy5EeW5hbWljQXJnLCBuYW1lLCB2YWx1ZV0pO1xuICB9XG5cbiAgeWllbGQodG86IG51bWJlcikge1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLnBvcFZhbHVlPFBhcmFtcz4oKTtcbiAgICB0aGlzLnB1c2goW09wcy5ZaWVsZCwgdG8sIHBhcmFtc10pO1xuICB9XG5cbiAgYXR0clNwbGF0KHRvOiBPcHRpb248bnVtYmVyPikge1xuICAgIHRoaXMucHVzaChbT3BzLkF0dHJTcGxhdCwgdG8hXSk7XG4gIH1cblxuICBkZWJ1Z2dlcihldmFsSW5mbzogT3B0aW9uPENvcmUuRXZhbEluZm8+KSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuRGVidWdnZXIsIGV2YWxJbmZvIV0pO1xuICAgIHRoaXMudGVtcGxhdGUuYmxvY2suaGFzRXZhbCA9IHRydWU7XG4gIH1cblxuICBoYXNCbG9jayhuYW1lOiBudW1iZXIpIHtcbiAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5IYXNCbG9jaz4oW09wcy5IYXNCbG9jaywgbmFtZV0pO1xuICB9XG5cbiAgaGFzQmxvY2tQYXJhbXMobmFtZTogbnVtYmVyKSB7XG4gICAgdGhpcy5wdXNoVmFsdWU8RXhwcmVzc2lvbnMuSGFzQmxvY2tQYXJhbXM+KFtPcHMuSGFzQmxvY2tQYXJhbXMsIG5hbWVdKTtcbiAgfVxuXG4gIHBhcnRpYWwoZXZhbEluZm86IE9wdGlvbjxDb3JlLkV2YWxJbmZvPikge1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLnBvcFZhbHVlPFBhcmFtcz4oKTtcbiAgICB0aGlzLnB1c2goW09wcy5QYXJ0aWFsLCBwYXJhbXNbMF0sIGV2YWxJbmZvIV0pO1xuICAgIHRoaXMudGVtcGxhdGUuYmxvY2suaGFzRXZhbCA9IHRydWU7XG4gIH1cblxuICAvLy8gRXhwcmVzc2lvbnNcblxuICBsaXRlcmFsKHZhbHVlOiBFeHByZXNzaW9ucy5WYWx1ZSB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5VbmRlZmluZWQ+KFtPcHMuVW5kZWZpbmVkXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFZhbHVlPEV4cHJlc3Npb25zLlZhbHVlPih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdW5rbm93bihuYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5Vbmtub3duPihbT3BzLlVua25vd24sIG5hbWVdKTtcbiAgfVxuXG4gIGdldChbaGVhZCwgcGF0aF06IFtudW1iZXIsIHN0cmluZ1tdXSkge1xuICAgIHRoaXMucHVzaFZhbHVlPEV4cHJlc3Npb25zLkdldD4oW09wcy5HZXQsIGhlYWQsIHBhdGhdKTtcbiAgfVxuXG4gIG1heWJlTG9jYWwocGF0aDogc3RyaW5nW10pIHtcbiAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5NYXliZUxvY2FsPihbT3BzLk1heWJlTG9jYWwsIHBhdGhdKTtcbiAgfVxuXG4gIGNvbmNhdCgpIHtcbiAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5Db25jYXQ+KFtPcHMuQ29uY2F0LCB0aGlzLnBvcFZhbHVlPFBhcmFtcz4oKV0pO1xuICB9XG5cbiAgaGVscGVyKG5hbWU6IHN0cmluZykge1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLnBvcFZhbHVlPFBhcmFtcz4oKTtcbiAgICBsZXQgaGFzaCA9IHRoaXMucG9wVmFsdWU8SGFzaD4oKTtcblxuICAgIHRoaXMucHVzaFZhbHVlPEV4cHJlc3Npb25zLkhlbHBlcj4oW09wcy5IZWxwZXIsIG5hbWUsIHBhcmFtcywgaGFzaF0pO1xuICB9XG5cbiAgLy8vIFN0YWNrIE1hbmFnZW1lbnQgT3Bjb2Rlc1xuXG4gIHByZXBhcmVBcnJheShzaXplOiBudW1iZXIpIHtcbiAgICBsZXQgdmFsdWVzOiBFeHByZXNzaW9uW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaCh0aGlzLnBvcFZhbHVlKCkgYXMgRXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoVmFsdWU8UGFyYW1zPih2YWx1ZXMpO1xuICB9XG5cbiAgcHJlcGFyZU9iamVjdChzaXplOiBudW1iZXIpIHtcbiAgICBhc3NlcnQoXG4gICAgICB0aGlzLnZhbHVlcy5sZW5ndGggPj0gc2l6ZSxcbiAgICAgIGBFeHBlY3RlZCAke3NpemV9IHZhbHVlcyBvbiB0aGUgc3RhY2ssIGZvdW5kICR7dGhpcy52YWx1ZXMubGVuZ3RofWBcbiAgICApO1xuXG4gICAgbGV0IGtleXM6IHN0cmluZ1tdID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGxldCB2YWx1ZXM6IEV4cHJlc3Npb25bXSA9IG5ldyBBcnJheShzaXplKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBrZXlzW2ldID0gdGhpcy5wb3BWYWx1ZTxzdHI+KCk7XG4gICAgICB2YWx1ZXNbaV0gPSB0aGlzLnBvcFZhbHVlPEV4cHJlc3Npb24+KCk7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoVmFsdWU8SGFzaD4oW2tleXMsIHZhbHVlc10pO1xuICB9XG5cbiAgLy8vIFV0aWxpdGllc1xuXG4gIGVuZENvbXBvbmVudCgpOiBbc3RyaW5nLCBTdGF0ZW1lbnRzLkF0dHJpYnV0ZVtdLCBDb3JlLkhhc2gsIE9wdGlvbjxTZXJpYWxpemVkSW5saW5lQmxvY2s+XSB7XG4gICAgbGV0IGNvbXBvbmVudCA9IHRoaXMuYmxvY2tzLnBvcCgpO1xuICAgIGFzc2VydChcbiAgICAgIGNvbXBvbmVudCBpbnN0YW5jZW9mIENvbXBvbmVudEJsb2NrLFxuICAgICAgJ0NvbXBpbGVyIGJ1ZzogZW5kQ29tcG9uZW50KCkgc2hvdWxkIGVuZCBhIGNvbXBvbmVudCdcbiAgICApO1xuXG4gICAgcmV0dXJuIChjb21wb25lbnQgYXMgQ29tcG9uZW50QmxvY2spLnRvSlNPTigpO1xuICB9XG5cbiAgcHVzaChhcmdzOiBTdGF0ZW1lbnQpIHtcbiAgICB3aGlsZSAoYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICBhcmdzLnBvcCgpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudEJsb2NrLnB1c2goYXJncyk7XG4gIH1cblxuICBwdXNoVmFsdWU8UyBleHRlbmRzIEV4cHJlc3Npb24gfCBQYXJhbXMgfCBIYXNoPih2YWw6IFMpIHtcbiAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbCk7XG4gIH1cblxuICBwb3BWYWx1ZTxUIGV4dGVuZHMgU3RhY2tWYWx1ZT4oKTogVCB7XG4gICAgYXNzZXJ0KHRoaXMudmFsdWVzLmxlbmd0aCwgJ05vIGV4cHJlc3Npb24gZm91bmQgb24gc3RhY2snKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMucG9wKCkgYXMgVDtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NPcGNvZGVzKGNvbXBpbGVyOiBhbnksIG9wY29kZXM6IGFueSkge1xuICBmb3IgKGxldCBpID0gMCwgbCA9IG9wY29kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IG1ldGhvZCA9IG9wY29kZXNbaV1bMF07XG4gICAgbGV0IHBhcmFtcyA9IG9wY29kZXNbaV1bMV07XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgY29tcGlsZXJbbWV0aG9kXS5hcHBseShjb21waWxlciwgcGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGlsZXJbbWV0aG9kXS5jYWxsKGNvbXBpbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlcmUgaXMgYSBzbWFsbCB3aGl0ZWxpc3Qgb2YgbmFtZXNwYWNlZCBhdHRyaWJ1dGVzIHNwZWNpYWxseVxuLy8gZW51bWVyYXRlZCBpblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWwvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0wXG4vL1xuLy8gPiBXaGVuIGEgZm9yZWlnbiBlbGVtZW50IGhhcyBvbmUgb2YgdGhlIG5hbWVzcGFjZWQgYXR0cmlidXRlcyBnaXZlbiBieVxuLy8gPiB0aGUgbG9jYWwgbmFtZSBhbmQgbmFtZXNwYWNlIG9mIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNlbGxzIG9mIGEgcm93XG4vLyA+IGZyb20gdGhlIGZvbGxvd2luZyB0YWJsZSwgaXQgbXVzdCBiZSB3cml0dGVuIHVzaW5nIHRoZSBuYW1lIGdpdmVuIGJ5XG4vLyA+IHRoZSB0aGlyZCBjZWxsIGZyb20gdGhlIHNhbWUgcm93LlxuLy9cbi8vIEluIGFsbCBvdGhlciBjYXNlcywgY29sb25zIGFyZSBpbnRlcnByZXRlZCBhcyBhIHJlZ3VsYXIgY2hhcmFjdGVyXG4vLyB3aXRoIG5vIHNwZWNpYWwgbWVhbmluZzpcbi8vXG4vLyA+IE5vIG90aGVyIG5hbWVzcGFjZWQgYXR0cmlidXRlIGNhbiBiZSBleHByZXNzZWQgaW4gdGhlIEhUTUwgc3ludGF4LlxuXG5jb25zdCBYTElOSyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbmNvbnN0IFhNTCA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnO1xuY29uc3QgWE1MTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nO1xuXG5jb25zdCBXSElURUxJU1QgPSB7XG4gICd4bGluazphY3R1YXRlJzogWExJTkssXG4gICd4bGluazphcmNyb2xlJzogWExJTkssXG4gICd4bGluazpocmVmJzogWExJTkssXG4gICd4bGluazpyb2xlJzogWExJTkssXG4gICd4bGluazpzaG93JzogWExJTkssXG4gICd4bGluazp0aXRsZSc6IFhMSU5LLFxuICAneGxpbms6dHlwZSc6IFhMSU5LLFxuICAneG1sOmJhc2UnOiBYTUwsXG4gICd4bWw6bGFuZyc6IFhNTCxcbiAgJ3htbDpzcGFjZSc6IFhNTCxcbiAgeG1sbnM6IFhNTE5TLFxuICAneG1sbnM6eGxpbmsnOiBYTUxOUyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyTmFtZXNwYWNlKGF0dHJOYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIFdISVRFTElTVFthdHRyTmFtZV0gfHwgbnVsbDtcbn1cbiIsImltcG9ydCB7IENvbXBpbGVyT3BzLCBQcm9jZXNzb3IsIE9wLCBPcE5hbWUsIFRlbXBsYXRlQ29tcGlsZXJPcHMsIFBhdGhIZWFkIH0gZnJvbSAnLi9jb21waWxlci1vcHMnO1xuaW1wb3J0IHsgQVNUIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IE9wdGlvbiwgT3BhcXVlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTdGFjaywgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBTeW1ib2xUYWJsZSB9IGZyb20gJy4vdGVtcGxhdGUtdmlzaXRvcic7XG5cbmV4cG9ydCB0eXBlIEluVmFyaWFibGUgPSBQYXRoSGVhZDtcbmV4cG9ydCB0eXBlIE91dFZhcmlhYmxlID0gbnVtYmVyO1xuXG5leHBvcnQgdHlwZSBPdXRPcDxLIGV4dGVuZHMga2V5b2YgQ29tcGlsZXJPcHM8T3V0VmFyaWFibGU+ID0gT3BOYW1lPiA9IE9wPFxuICBPdXRWYXJpYWJsZSxcbiAgQ29tcGlsZXJPcHM8T3V0VmFyaWFibGU+LFxuICBLXG4+O1xuZXhwb3J0IHR5cGUgSW5PcDxLIGV4dGVuZHMga2V5b2YgVGVtcGxhdGVDb21waWxlck9wcyA9IGtleW9mIFRlbXBsYXRlQ29tcGlsZXJPcHM+ID0gT3A8XG4gIFBhdGhIZWFkLFxuICBUZW1wbGF0ZUNvbXBpbGVyT3BzLFxuICBLXG4+O1xuXG5leHBvcnQgY2xhc3MgU3ltYm9sQWxsb2NhdG9yXG4gIGltcGxlbWVudHMgUHJvY2Vzc29yPENvbXBpbGVyT3BzPEluVmFyaWFibGU+LCBPdXRWYXJpYWJsZSwgQ29tcGlsZXJPcHM8T3V0VmFyaWFibGU+PiB7XG4gIHByaXZhdGUgc3ltYm9sU3RhY2sgPSBuZXcgU3RhY2s8U3ltYm9sVGFibGU+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvcHM6IEFycmF5PEluT3A+KSB7fVxuXG4gIHByb2Nlc3MoKTogT3V0T3BbXSB7XG4gICAgbGV0IG91dDogT3V0T3BbXSA9IFtdO1xuICAgIGxldCB7IG9wcyB9ID0gdGhpcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3AgPSBvcHNbaV07XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kaXNwYXRjaChvcCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXQucHVzaChvcCBhcyBPdXRPcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQucHVzaChyZXN1bHQgYXMgYW55KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgZGlzcGF0Y2g8TyBleHRlbmRzIEluT3A+KG9wOiBPKTogT3BhcXVlIHtcbiAgICBsZXQgbmFtZSA9IG9wWzBdO1xuICAgIGxldCBvcGVyYW5kID0gb3BbMV07XG5cbiAgICByZXR1cm4gKHRoaXNbbmFtZV0gYXMgYW55KShvcGVyYW5kKTtcbiAgfVxuXG4gIGdldCBzeW1ib2xzKCk6IFN5bWJvbFRhYmxlIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuc3ltYm9sU3RhY2suY3VycmVudCwgJ0V4cGVjdGVkIGEgc3ltYm9sIHRhYmxlIG9uIHRoZSBzdGFjaycpO1xuICB9XG5cbiAgc3RhcnRQcm9ncmFtKG9wOiBBU1QuUHJvZ3JhbSkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucHVzaChvcFsnc3ltYm9scyddKTtcbiAgfVxuXG4gIGVuZFByb2dyYW0oX29wOiBudWxsKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgfVxuXG4gIHN0YXJ0QmxvY2sob3A6IEFTVC5Qcm9ncmFtKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wdXNoKG9wWydzeW1ib2xzJ10pO1xuICB9XG5cbiAgZW5kQmxvY2soX29wOiBudWxsKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGZsdXNoRWxlbWVudChvcDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wdXNoKG9wWydzeW1ib2xzJ10pO1xuICB9XG5cbiAgY2xvc2VFbGVtZW50KF9vcDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGNsb3NlQ29tcG9uZW50KF9vcDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGNsb3NlRHluYW1pY0NvbXBvbmVudChfb3A6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucG9wKCk7XG4gIH1cblxuICBhdHRyU3BsYXQoX29wOiBPcHRpb248SW5WYXJpYWJsZT4pOiBPdXRPcDwnYXR0clNwbGF0Jz4ge1xuICAgIHJldHVybiBbJ2F0dHJTcGxhdCcsIHRoaXMuc3ltYm9scy5hbGxvY2F0ZUJsb2NrKCdhdHRycycpXTtcbiAgfVxuXG4gIGdldChvcDogW0luVmFyaWFibGUsIHN0cmluZ1tdXSk6IE91dE9wPCdnZXQnIHwgJ21heWJlTG9jYWwnPiB7XG4gICAgbGV0IFtuYW1lLCByZXN0XSA9IG9wO1xuXG4gICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgIHJldHVybiBbJ2dldCcsIFswLCByZXN0XV07XG4gICAgfVxuXG4gICAgaWYgKGlzTG9jYWwobmFtZSwgdGhpcy5zeW1ib2xzKSkge1xuICAgICAgbGV0IGhlYWQgPSB0aGlzLnN5bWJvbHMuZ2V0KG5hbWUpO1xuICAgICAgcmV0dXJuIFsnZ2V0JywgW2hlYWQsIHJlc3RdXTtcbiAgICB9IGVsc2UgaWYgKG5hbWVbMF0gPT09ICdAJykge1xuICAgICAgbGV0IGhlYWQgPSB0aGlzLnN5bWJvbHMuYWxsb2NhdGVOYW1lZChuYW1lKTtcbiAgICAgIHJldHVybiBbJ2dldCcsIFtoZWFkLCByZXN0XV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbJ21heWJlTG9jYWwnLCBbbmFtZSwgLi4ucmVzdF1dO1xuICAgIH1cbiAgfVxuXG4gIG1heWJlR2V0KG9wOiBbSW5WYXJpYWJsZSwgc3RyaW5nW11dKTogT3V0T3A8J2dldCcgfCAndW5rbm93bicgfCAnbWF5YmVMb2NhbCc+IHtcbiAgICBsZXQgW25hbWUsIHJlc3RdID0gb3A7XG5cbiAgICBpZiAobmFtZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFsnZ2V0JywgWzAsIHJlc3RdXTtcbiAgICB9XG5cbiAgICBpZiAoaXNMb2NhbChuYW1lLCB0aGlzLnN5bWJvbHMpKSB7XG4gICAgICBsZXQgaGVhZCA9IHRoaXMuc3ltYm9scy5nZXQobmFtZSk7XG4gICAgICByZXR1cm4gWydnZXQnLCBbaGVhZCwgcmVzdF1dO1xuICAgIH0gZWxzZSBpZiAobmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgICBsZXQgaGVhZCA9IHRoaXMuc3ltYm9scy5hbGxvY2F0ZU5hbWVkKG5hbWUpO1xuICAgICAgcmV0dXJuIFsnZ2V0JywgW2hlYWQsIHJlc3RdXTtcbiAgICB9IGVsc2UgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gWyd1bmtub3duJywgbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbJ21heWJlTG9jYWwnLCBbbmFtZSwgLi4ucmVzdF1dO1xuICAgIH1cbiAgfVxuXG4gIHlpZWxkKG9wOiBJblZhcmlhYmxlKTogT3V0T3A8J3lpZWxkJz4ge1xuICAgIGlmIChvcCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgeWllbGQgdG8gdGhpcycpO1xuICAgIH1cblxuICAgIHJldHVybiBbJ3lpZWxkJywgdGhpcy5zeW1ib2xzLmFsbG9jYXRlQmxvY2sob3ApXTtcbiAgfVxuXG4gIGRlYnVnZ2VyKF9vcDogT3B0aW9uPEluVmFyaWFibGVbXT4pOiBPdXRPcDwnZGVidWdnZXInPiB7XG4gICAgcmV0dXJuIFsnZGVidWdnZXInLCB0aGlzLnN5bWJvbHMuZ2V0RXZhbEluZm8oKV07XG4gIH1cblxuICBoYXNCbG9jayhvcDogSW5WYXJpYWJsZSk6IE91dE9wPCdoYXNCbG9jayc+IHtcbiAgICBpZiAob3AgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhc0Jsb2NrIHRoaXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWydoYXNCbG9jaycsIHRoaXMuc3ltYm9scy5hbGxvY2F0ZUJsb2NrKG9wKV07XG4gIH1cblxuICBoYXNCbG9ja1BhcmFtcyhvcDogSW5WYXJpYWJsZSk6IE91dE9wPCdoYXNCbG9ja1BhcmFtcyc+IHtcbiAgICBpZiAob3AgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhc0Jsb2NrUGFyYW1zIHRoaXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWydoYXNCbG9ja1BhcmFtcycsIHRoaXMuc3ltYm9scy5hbGxvY2F0ZUJsb2NrKG9wKV07XG4gIH1cblxuICBwYXJ0aWFsKF9vcDogT3B0aW9uPEluVmFyaWFibGVbXT4pOiBPdXRPcDwncGFydGlhbCc+IHtcbiAgICByZXR1cm4gWydwYXJ0aWFsJywgdGhpcy5zeW1ib2xzLmdldEV2YWxJbmZvKCldO1xuICB9XG5cbiAgdGV4dChfb3A6IHN0cmluZykge31cbiAgY29tbWVudChfb3A6IHN0cmluZykge31cbiAgb3BlbkNvbXBvbmVudChfb3A6IEFTVC5FbGVtZW50Tm9kZSkge31cbiAgb3BlbkVsZW1lbnQoX29wOiBBU1QuRWxlbWVudE5vZGUpIHt9XG4gIG9wZW5TcGxhdHRlZEVsZW1lbnQoX29wOiBBU1QuRWxlbWVudE5vZGUpIHt9XG4gIHN0YXRpY0FyZyhfb3A6IHN0cmluZykge31cbiAgZHluYW1pY0FyZyhfb3A6IHN0cmluZykge31cbiAgc3RhdGljQXR0cihfb3A6IFtzdHJpbmcsIE9wdGlvbjxzdHJpbmc+XSkge31cbiAgdHJ1c3RpbmdBdHRyKF9vcDogW3N0cmluZywgT3B0aW9uPHN0cmluZz5dKSB7fVxuICBkeW5hbWljQXR0cihfb3A6IFtzdHJpbmcsIE9wdGlvbjxzdHJpbmc+XSkge31cbiAgbW9kaWZpZXIoX29wOiBzdHJpbmcpIHt9XG4gIGFwcGVuZChfb3A6IGJvb2xlYW4pIHt9XG4gIGJsb2NrKF9vcDogW3N0cmluZywgbnVtYmVyLCBPcHRpb248bnVtYmVyPl0pIHt9XG4gIGxpdGVyYWwoX29wOiBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCkge31cbiAgaGVscGVyKF9vcDogc3RyaW5nKSB7fVxuICB1bmtub3duKF9vcDogc3RyaW5nKSB7fVxuICBtYXliZUxvY2FsKF9vcDogc3RyaW5nW10pIHt9XG4gIHByZXBhcmVBcnJheShfb3A6IG51bWJlcikge31cbiAgcHJlcGFyZU9iamVjdChfb3A6IG51bWJlcikge31cbiAgY29uY2F0KF9vcDogbnVsbCkge31cbn1cblxuZnVuY3Rpb24gaXNMb2NhbChuYW1lOiBzdHJpbmcsIHN5bWJvbHM6IFN5bWJvbFRhYmxlKTogYm9vbGVhbiB7XG4gIHJldHVybiBzeW1ib2xzICYmIHN5bWJvbHMuaGFzKG5hbWUpO1xufVxuIiwiaW1wb3J0IFRlbXBsYXRlVmlzaXRvciwgeyBBY3Rpb24gfSBmcm9tICcuL3RlbXBsYXRlLXZpc2l0b3InO1xuaW1wb3J0IEphdmFTY3JpcHRDb21waWxlciwgeyBUZW1wbGF0ZSB9IGZyb20gJy4vamF2YXNjcmlwdC1jb21waWxlcic7XG5pbXBvcnQgeyBhc3NlcnQsIE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVNULCBpc0xpdGVyYWwsIFN5bnRheEVycm9yIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IGdldEF0dHJOYW1lc3BhY2UgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IE9wYXF1ZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU3ltYm9sQWxsb2NhdG9yLCBJbk9wIGFzIFN5bWJvbEluT3AsIE91dE9wIGFzIFN5bWJvbE91dE9wIH0gZnJvbSAnLi9hbGxvY2F0ZS1zeW1ib2xzJztcbmltcG9ydCB7IFBhdGhIZWFkIH0gZnJvbSAnLi9jb21waWxlci1vcHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBpbGVPcHRpb25zIHtcbiAgbWV0YTogT3BhcXVlO1xuICBjdXN0b21pemVDb21wb25lbnROYW1lPyh0YWc6IHN0cmluZyk6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gaXNUcnVzdGVkVmFsdWUodmFsdWU6IGFueSkge1xuICByZXR1cm4gdmFsdWUuZXNjYXBlZCAhPT0gdW5kZWZpbmVkICYmICF2YWx1ZS5lc2NhcGVkO1xufVxuXG5leHBvcnQgY29uc3QgVEhJUyA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlQ29tcGlsZXIge1xuICBzdGF0aWMgY29tcGlsZShhc3Q6IEFTVC5Qcm9ncmFtLCBvcHRpb25zPzogQ29tcGlsZU9wdGlvbnMpOiBUZW1wbGF0ZSB7XG4gICAgbGV0IHRlbXBsYXRlVmlzaXRvciA9IG5ldyBUZW1wbGF0ZVZpc2l0b3IoKTtcbiAgICB0ZW1wbGF0ZVZpc2l0b3IudmlzaXQoYXN0KTtcblxuICAgIGxldCBjb21waWxlciA9IG5ldyBUZW1wbGF0ZUNvbXBpbGVyKCk7XG4gICAgbGV0IG9wY29kZXM6IFN5bWJvbEluT3BbXSA9IGNvbXBpbGVyLnByb2Nlc3ModGVtcGxhdGVWaXNpdG9yLmFjdGlvbnMpO1xuICAgIGxldCBzeW1ib2xzOiBTeW1ib2xPdXRPcFtdID0gbmV3IFN5bWJvbEFsbG9jYXRvcihvcGNvZGVzKS5wcm9jZXNzKCk7XG5cbiAgICByZXR1cm4gSmF2YVNjcmlwdENvbXBpbGVyLnByb2Nlc3Moc3ltYm9scywgYXN0WydzeW1ib2xzJ10sIG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSB0ZW1wbGF0ZUlkID0gMDtcbiAgcHJpdmF0ZSB0ZW1wbGF0ZUlkczogbnVtYmVyW10gPSBbXTtcbiAgcHJpdmF0ZSBvcGNvZGVzOiBTeW1ib2xJbk9wW10gPSBbXTtcbiAgcHJpdmF0ZSBpbmNsdWRlTWV0YSA9IGZhbHNlO1xuXG4gIHByb2Nlc3MoYWN0aW9uczogQWN0aW9uW10pOiBTeW1ib2xJbk9wW10ge1xuICAgIGFjdGlvbnMuZm9yRWFjaCgoW25hbWUsIC4uLmFyZ3NdKSA9PiB7XG4gICAgICBpZiAoIXRoaXNbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmltcGxlbWVudGVkICR7bmFtZX0gb24gVGVtcGxhdGVDb21waWxlcmApO1xuICAgICAgfVxuICAgICAgKHRoaXNbbmFtZV0gYXMgYW55KSguLi5hcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5vcGNvZGVzO1xuICB9XG5cbiAgc3RhcnRQcm9ncmFtKFtwcm9ncmFtXTogW0FTVC5Qcm9ncmFtXSkge1xuICAgIHRoaXMub3Bjb2RlKFsnc3RhcnRQcm9ncmFtJywgcHJvZ3JhbV0sIHByb2dyYW0pO1xuICB9XG5cbiAgZW5kUHJvZ3JhbSgpIHtcbiAgICB0aGlzLm9wY29kZShbJ2VuZFByb2dyYW0nLCBudWxsXSwgbnVsbCk7XG4gIH1cblxuICBzdGFydEJsb2NrKFtwcm9ncmFtXTogW0FTVC5Qcm9ncmFtXSkge1xuICAgIHRoaXMudGVtcGxhdGVJZCsrO1xuICAgIHRoaXMub3Bjb2RlKFsnc3RhcnRCbG9jaycsIHByb2dyYW1dLCBwcm9ncmFtKTtcbiAgfVxuXG4gIGVuZEJsb2NrKCkge1xuICAgIHRoaXMudGVtcGxhdGVJZHMucHVzaCh0aGlzLnRlbXBsYXRlSWQgLSAxKTtcbiAgICB0aGlzLm9wY29kZShbJ2VuZEJsb2NrJywgbnVsbF0sIG51bGwpO1xuICB9XG5cbiAgdGV4dChbYWN0aW9uXTogW0FTVC5UZXh0Tm9kZV0pIHtcbiAgICB0aGlzLm9wY29kZShbJ3RleHQnLCBhY3Rpb24uY2hhcnNdLCBhY3Rpb24pO1xuICB9XG5cbiAgY29tbWVudChbYWN0aW9uXTogW0FTVC5Db21tZW50U3RhdGVtZW50XSkge1xuICAgIHRoaXMub3Bjb2RlKFsnY29tbWVudCcsIGFjdGlvbi52YWx1ZV0sIGFjdGlvbik7XG4gIH1cblxuICBvcGVuRWxlbWVudChbYWN0aW9uXTogW0FTVC5FbGVtZW50Tm9kZV0pIHtcbiAgICBsZXQgYXR0cmlidXRlcyA9IGFjdGlvbi5hdHRyaWJ1dGVzO1xuICAgIGxldCBoYXNTcGxhdDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgaWYgKGF0dHIubmFtZSA9PT0gJy4uLmF0dHJpYnV0ZXMnKSB7XG4gICAgICAgIGhhc1NwbGF0ID0gYXR0cjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRHluYW1pY0NvbXBvbmVudChhY3Rpb24pKSB7XG4gICAgICBsZXQgaGVhZDogUGF0aEhlYWQsIHJlc3Q6IHN0cmluZ1tdO1xuICAgICAgW2hlYWQsIC4uLnJlc3RdID0gYWN0aW9uLnRhZy5zcGxpdCgnLicpO1xuICAgICAgaWYgKGhlYWQgPT09ICd0aGlzJykge1xuICAgICAgICBoZWFkID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMub3Bjb2RlKFsnZ2V0JywgW2hlYWQsIHJlc3RdXSk7XG4gICAgICB0aGlzLm9wY29kZShbJ29wZW5Db21wb25lbnQnLCBhY3Rpb25dLCBhY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoaXNDb21wb25lbnQoYWN0aW9uKSkge1xuICAgICAgdGhpcy5vcGNvZGUoWydvcGVuQ29tcG9uZW50JywgYWN0aW9uXSwgYWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGhhc1NwbGF0KSB7XG4gICAgICB0aGlzLm9wY29kZShbJ29wZW5TcGxhdHRlZEVsZW1lbnQnLCBhY3Rpb25dLCBhY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wY29kZShbJ29wZW5FbGVtZW50JywgYWN0aW9uXSwgYWN0aW9uKTtcbiAgICB9XG5cbiAgICBsZXQgdHlwZUF0dHI6IE9wdGlvbjxBU1QuQXR0ck5vZGU+ID0gbnVsbDtcbiAgICBsZXQgYXR0cnMgPSBhY3Rpb24uYXR0cmlidXRlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ubmFtZSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgIHR5cGVBdHRyID0gYXR0cnNbaV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5hdHRyaWJ1dGUoW2F0dHJzW2ldXSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVBdHRyKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZShbdHlwZUF0dHJdKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wY29kZShbJ2ZsdXNoRWxlbWVudCcsIGFjdGlvbl0sIG51bGwpO1xuICB9XG5cbiAgY2xvc2VFbGVtZW50KFthY3Rpb25dOiBbQVNULkVsZW1lbnROb2RlXSkge1xuICAgIGlmIChpc0R5bmFtaWNDb21wb25lbnQoYWN0aW9uKSkge1xuICAgICAgdGhpcy5vcGNvZGUoWydjbG9zZUR5bmFtaWNDb21wb25lbnQnLCBhY3Rpb25dLCBhY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoaXNDb21wb25lbnQoYWN0aW9uKSkge1xuICAgICAgdGhpcy5vcGNvZGUoWydjbG9zZUNvbXBvbmVudCcsIGFjdGlvbl0sIGFjdGlvbik7XG4gICAgfSBlbHNlIGlmIChhY3Rpb24ubW9kaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9uLm1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLm1vZGlmaWVyKFthY3Rpb24ubW9kaWZpZXJzW2ldXSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wY29kZShbJ2Nsb3NlRWxlbWVudCcsIGFjdGlvbl0sIGFjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3Bjb2RlKFsnY2xvc2VFbGVtZW50JywgYWN0aW9uXSwgYWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBhdHRyaWJ1dGUoW2FjdGlvbl06IFtBU1QuQXR0ck5vZGVdKSB7XG4gICAgbGV0IHsgbmFtZSwgdmFsdWUgfSA9IGFjdGlvbjtcblxuICAgIGxldCBuYW1lc3BhY2UgPSBnZXRBdHRyTmFtZXNwYWNlKG5hbWUpO1xuXG4gICAgbGV0IGlzU3RhdGljID0gdGhpcy5wcmVwYXJlQXR0cmlidXRlVmFsdWUodmFsdWUpO1xuXG4gICAgaWYgKG5hbWUuY2hhckF0KDApID09PSAnQCcpIHtcbiAgICAgIC8vIEFyZ3VtZW50c1xuICAgICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKFsnc3RhdGljQXJnJywgbmFtZV0sIGFjdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbi52YWx1ZS50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnKSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKFsnZHluYW1pY0FyZycsIG5hbWVdLCBhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoWydkeW5hbWljQXJnJywgbmFtZV0sIGFjdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBpc1RydXN0aW5nID0gaXNUcnVzdGVkVmFsdWUodmFsdWUpO1xuXG4gICAgICBpZiAoaXNTdGF0aWMgJiYgbmFtZSA9PT0gJy4uLmF0dHJpYnV0ZXMnKSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKFsnYXR0clNwbGF0JywgbnVsbF0sIGFjdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKFsnc3RhdGljQXR0cicsIFtuYW1lLCBuYW1lc3BhY2VdXSwgYWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUcnVzdGluZykge1xuICAgICAgICB0aGlzLm9wY29kZShbJ3RydXN0aW5nQXR0cicsIFtuYW1lLCBuYW1lc3BhY2VdXSwgYWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLnZhbHVlLnR5cGUgPT09ICdNdXN0YWNoZVN0YXRlbWVudCcpIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoWydkeW5hbWljQXR0cicsIFtuYW1lLCBudWxsXV0sIGFjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wY29kZShbJ2R5bmFtaWNBdHRyJywgW25hbWUsIG5hbWVzcGFjZV1dLCBhY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG1vZGlmaWVyKFthY3Rpb25dOiBbQVNULkVsZW1lbnRNb2RpZmllclN0YXRlbWVudF0pIHtcbiAgICBhc3NlcnRJc1NpbXBsZVBhdGgoYWN0aW9uLnBhdGgsIGFjdGlvbi5sb2MsICdtb2RpZmllcicpO1xuXG4gICAgbGV0IHtcbiAgICAgIHBhdGg6IHsgcGFydHMgfSxcbiAgICB9ID0gYWN0aW9uO1xuXG4gICAgdGhpcy5wcmVwYXJlSGVscGVyKGFjdGlvbik7XG4gICAgdGhpcy5vcGNvZGUoWydtb2RpZmllcicsIHBhcnRzWzBdXSwgYWN0aW9uKTtcbiAgfVxuXG4gIG11c3RhY2hlKFthY3Rpb25dOiBbQVNULk11c3RhY2hlU3RhdGVtZW50XSkge1xuICAgIGxldCB7IHBhdGggfSA9IGFjdGlvbjtcblxuICAgIGlmIChpc0xpdGVyYWwocGF0aCkpIHtcbiAgICAgIHRoaXMubXVzdGFjaGVFeHByZXNzaW9uKGFjdGlvbik7XG4gICAgICB0aGlzLm9wY29kZShbJ2FwcGVuZCcsICFhY3Rpb24uZXNjYXBlZF0sIGFjdGlvbik7XG4gICAgfSBlbHNlIGlmIChpc1lpZWxkKHBhdGgpKSB7XG4gICAgICBsZXQgdG8gPSBhc3NlcnRWYWxpZFlpZWxkKGFjdGlvbik7XG4gICAgICB0aGlzLnlpZWxkKHRvLCBhY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoaXNQYXJ0aWFsKHBhdGgpKSB7XG4gICAgICBsZXQgcGFyYW1zID0gYXNzZXJ0VmFsaWRQYXJ0aWFsKGFjdGlvbik7XG4gICAgICB0aGlzLnBhcnRpYWwocGFyYW1zLCBhY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoaXNEZWJ1Z2dlcihwYXRoKSkge1xuICAgICAgYXNzZXJ0VmFsaWREZWJ1Z2dlclVzYWdlKGFjdGlvbik7XG4gICAgICB0aGlzLmRlYnVnZ2VyKCdkZWJ1Z2dlcicsIGFjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubXVzdGFjaGVFeHByZXNzaW9uKGFjdGlvbik7XG4gICAgICB0aGlzLm9wY29kZShbJ2FwcGVuZCcsICFhY3Rpb24uZXNjYXBlZF0sIGFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgYmxvY2soW2FjdGlvbiAvKiwgaW5kZXgsIGNvdW50Ki9dOiBbQVNULkJsb2NrU3RhdGVtZW50XSkge1xuICAgIHRoaXMucHJlcGFyZUhlbHBlcihhY3Rpb24pO1xuICAgIGxldCB0ZW1wbGF0ZUlkID0gdGhpcy50ZW1wbGF0ZUlkcy5wb3AoKSE7XG4gICAgbGV0IGludmVyc2VJZCA9IGFjdGlvbi5pbnZlcnNlID09PSBudWxsID8gbnVsbCA6IHRoaXMudGVtcGxhdGVJZHMucG9wKCkhO1xuICAgIHRoaXMub3Bjb2RlKFsnYmxvY2snLCBbYWN0aW9uLnBhdGgucGFydHNbMF0sIHRlbXBsYXRlSWQsIGludmVyc2VJZF1dLCBhY3Rpb24pO1xuICB9XG5cbiAgLy8vIEludGVybmFsIGFjdGlvbnMsIG5vdCBmb3VuZCBpbiB0aGUgb3JpZ2luYWwgcHJvY2Vzc2VkIGFjdGlvbnNcblxuICBhcmcoW3BhdGhdOiBbQVNULlBhdGhFeHByZXNzaW9uXSkge1xuICAgIGxldCB7XG4gICAgICBwYXJ0czogW2hlYWQsIC4uLnJlc3RdLFxuICAgIH0gPSBwYXRoO1xuICAgIHRoaXMub3Bjb2RlKFsnZ2V0JywgW2BAJHtoZWFkfWAsIHJlc3RdXSwgcGF0aCk7XG4gIH1cblxuICBtdXN0YWNoZUV4cHJlc3Npb24oZXhwcjogQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gICAgbGV0IHsgcGF0aCB9ID0gZXhwcjtcblxuICAgIGlmIChpc0xpdGVyYWwocGF0aCkpIHtcbiAgICAgIHRoaXMub3Bjb2RlKFsnbGl0ZXJhbCcsIHBhdGgudmFsdWVdLCBleHByKTtcbiAgICB9IGVsc2UgaWYgKGlzQnVpbHRJbkhlbHBlcihwYXRoKSkge1xuICAgICAgdGhpcy5idWlsdEluSGVscGVyKGV4cHIgYXMgQVNULkNhbGwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcmcocGF0aCkpIHtcbiAgICAgIHRoaXMuYXJnKFtwYXRoXSk7XG4gICAgfSBlbHNlIGlmIChpc0hlbHBlckludm9jYXRpb24oZXhwcikpIHtcbiAgICAgIHRoaXMucHJlcGFyZUhlbHBlcihleHByKTtcbiAgICAgIHRoaXMub3Bjb2RlKFsnaGVscGVyJywgcGF0aC5wYXJ0c1swXV0sIGV4cHIpO1xuICAgIH0gZWxzZSBpZiAocGF0aC50aGlzKSB7XG4gICAgICB0aGlzLm9wY29kZShbJ2dldCcsIFswLCBwYXRoLnBhcnRzXV0sIGV4cHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgW2hlYWQsIC4uLnBhcnRzXSA9IHBhdGgucGFydHM7XG4gICAgICB0aGlzLm9wY29kZShbJ21heWJlR2V0JywgW2hlYWQsIHBhcnRzXV0sIGV4cHIpO1xuICAgIH1cblxuICAgIC8vIH0gZWxzZSBpZiAoaXNMb2NhbChwYXRoLCB0aGlzLnN5bWJvbHMpKSB7XG4gICAgLy8gICBsZXQgW2hlYWQsIC4uLnBhcnRzXSA9IHBhdGgucGFydHM7XG4gICAgLy8gICB0aGlzLm9wY29kZShbJ2dldCcsIFtoZWFkLCBwYXJ0c11dLCBleHByKTtcbiAgICAvLyB9IGVsc2UgaWYgKGlzU2ltcGxlUGF0aChwYXRoKSkge1xuICAgIC8vICAgdGhpcy5vcGNvZGUoWyd1bmtub3duJywgcGF0aC5wYXJ0c1swXV0sIGV4cHIpO1xuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICB0aGlzLm9wY29kZShbJ21heWJlTG9jYWwnLCBwYXRoLnBhcnRzXSwgZXhwcik7XG4gICAgLy8gfVxuICB9XG5cbiAgLy8vIEludGVybmFsIFN5bnRheFxuXG4gIHlpZWxkKHRvOiBzdHJpbmcsIGFjdGlvbjogQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gICAgdGhpcy5wcmVwYXJlUGFyYW1zKGFjdGlvbi5wYXJhbXMpO1xuICAgIHRoaXMub3Bjb2RlKFsneWllbGQnLCB0b10sIGFjdGlvbik7XG4gIH1cblxuICBkZWJ1Z2dlcihfbmFtZTogc3RyaW5nLCBhY3Rpb246IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICAgIHRoaXMub3Bjb2RlKFsnZGVidWdnZXInLCBudWxsXSwgYWN0aW9uKTtcbiAgfVxuXG4gIGhhc0Jsb2NrKG5hbWU6IHN0cmluZywgYWN0aW9uOiBBU1QuQ2FsbCkge1xuICAgIHRoaXMub3Bjb2RlKFsnaGFzQmxvY2snLCBuYW1lXSwgYWN0aW9uKTtcbiAgfVxuXG4gIGhhc0Jsb2NrUGFyYW1zKG5hbWU6IHN0cmluZywgYWN0aW9uOiBBU1QuQ2FsbCkge1xuICAgIHRoaXMub3Bjb2RlKFsnaGFzQmxvY2tQYXJhbXMnLCBuYW1lXSwgYWN0aW9uKTtcbiAgfVxuXG4gIHBhcnRpYWwoX3BhcmFtczogQVNULkV4cHJlc3Npb25bXSwgYWN0aW9uOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnByZXBhcmVQYXJhbXMoYWN0aW9uLnBhcmFtcyk7XG4gICAgdGhpcy5vcGNvZGUoWydwYXJ0aWFsJywgbnVsbF0sIGFjdGlvbik7XG4gIH1cblxuICBidWlsdEluSGVscGVyKGV4cHI6IEFTVC5DYWxsKSB7XG4gICAgbGV0IHsgcGF0aCB9ID0gZXhwcjtcbiAgICBpZiAoaXNIYXNCbG9jayhwYXRoKSkge1xuICAgICAgbGV0IG5hbWUgPSBhc3NlcnRWYWxpZEhhc0Jsb2NrVXNhZ2UoZXhwci5wYXRoLm9yaWdpbmFsLCBleHByKTtcbiAgICAgIHRoaXMuaGFzQmxvY2sobmFtZSwgZXhwcik7XG4gICAgfSBlbHNlIGlmIChpc0hhc0Jsb2NrUGFyYW1zKHBhdGgpKSB7XG4gICAgICBsZXQgbmFtZSA9IGFzc2VydFZhbGlkSGFzQmxvY2tVc2FnZShleHByLnBhdGgub3JpZ2luYWwsIGV4cHIpO1xuICAgICAgdGhpcy5oYXNCbG9ja1BhcmFtcyhuYW1lLCBleHByKTtcbiAgICB9XG4gIH1cblxuICAvLy8gRXhwcmVzc2lvbnMsIGludm9rZWQgcmVjdXJzaXZlbHkgZnJvbSBwcmVwYXJlUGFyYW1zIGFuZCBwcmVwYXJlSGFzaFxuXG4gIFN1YkV4cHJlc3Npb24oZXhwcjogQVNULlN1YkV4cHJlc3Npb24pIHtcbiAgICBpZiAoaXNCdWlsdEluSGVscGVyKGV4cHIucGF0aCkpIHtcbiAgICAgIHRoaXMuYnVpbHRJbkhlbHBlcihleHByKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVwYXJlSGVscGVyKGV4cHIpO1xuICAgICAgdGhpcy5vcGNvZGUoWydoZWxwZXInLCBleHByLnBhdGgucGFydHNbMF1dLCBleHByKTtcbiAgICB9XG4gIH1cblxuICBQYXRoRXhwcmVzc2lvbihleHByOiBBU1QuUGF0aEV4cHJlc3Npb24pIHtcbiAgICBpZiAoZXhwci5kYXRhKSB7XG4gICAgICB0aGlzLmFyZyhbZXhwcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgW2hlYWQsIC4uLnJlc3RdID0gZXhwci5wYXJ0cztcblxuICAgICAgaWYgKGV4cHIudGhpcykge1xuICAgICAgICB0aGlzLm9wY29kZShbJ2dldCcsIFswLCBleHByLnBhcnRzXV0sIGV4cHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoWydnZXQnLCBbaGVhZCwgcmVzdF1dLCBleHByKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBTdHJpbmdMaXRlcmFsKGFjdGlvbjogQVNULlN0cmluZ0xpdGVyYWwpIHtcbiAgICB0aGlzLm9wY29kZShbJ2xpdGVyYWwnLCBhY3Rpb24udmFsdWVdLCBhY3Rpb24pO1xuICB9XG5cbiAgQm9vbGVhbkxpdGVyYWwoYWN0aW9uOiBBU1QuQm9vbGVhbkxpdGVyYWwpIHtcbiAgICB0aGlzLm9wY29kZShbJ2xpdGVyYWwnLCBhY3Rpb24udmFsdWVdLCBhY3Rpb24pO1xuICB9XG5cbiAgTnVtYmVyTGl0ZXJhbChhY3Rpb246IEFTVC5OdW1iZXJMaXRlcmFsKSB7XG4gICAgdGhpcy5vcGNvZGUoWydsaXRlcmFsJywgYWN0aW9uLnZhbHVlXSwgYWN0aW9uKTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKGFjdGlvbjogQVNULk51bGxMaXRlcmFsKSB7XG4gICAgdGhpcy5vcGNvZGUoWydsaXRlcmFsJywgYWN0aW9uLnZhbHVlXSwgYWN0aW9uKTtcbiAgfVxuXG4gIFVuZGVmaW5lZExpdGVyYWwoYWN0aW9uOiBBU1QuVW5kZWZpbmVkTGl0ZXJhbCkge1xuICAgIHRoaXMub3Bjb2RlKFsnbGl0ZXJhbCcsIGFjdGlvbi52YWx1ZV0sIGFjdGlvbik7XG4gIH1cblxuICAvLy8gVXRpbGl0aWVzXG5cbiAgb3Bjb2RlPE8gZXh0ZW5kcyBTeW1ib2xJbk9wPihvcGNvZGU6IE8sIGFjdGlvbjogT3B0aW9uPEFTVC5CYXNlTm9kZT4gPSBudWxsKSB7XG4gICAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IHJlYWxseSB3b3JrXG4gICAgaWYgKHRoaXMuaW5jbHVkZU1ldGEgJiYgYWN0aW9uKSB7XG4gICAgICAob3Bjb2RlIGFzIGFueSkucHVzaCh0aGlzLm1ldGEoYWN0aW9uKSk7XG4gICAgfVxuXG4gICAgdGhpcy5vcGNvZGVzLnB1c2gob3Bjb2RlKTtcbiAgfVxuXG4gIHByZXBhcmVIZWxwZXIoZXhwcjogQVNULkNhbGwpIHtcbiAgICBhc3NlcnRJc1NpbXBsZVBhdGgoZXhwci5wYXRoLCBleHByLmxvYywgJ2hlbHBlcicpO1xuXG4gICAgbGV0IHsgcGFyYW1zLCBoYXNoIH0gPSBleHByO1xuXG4gICAgdGhpcy5wcmVwYXJlSGFzaChoYXNoKTtcbiAgICB0aGlzLnByZXBhcmVQYXJhbXMocGFyYW1zKTtcbiAgfVxuXG4gIHByZXBhcmVQYXJhbXMocGFyYW1zOiBBU1QuRXhwcmVzc2lvbltdKSB7XG4gICAgaWYgKCFwYXJhbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9wY29kZShbJ2xpdGVyYWwnLCBudWxsXSwgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IHBhcmFtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IHBhcmFtID0gcGFyYW1zW2ldO1xuXG4gICAgICBhc3NlcnQodGhpc1twYXJhbS50eXBlXSwgYFVuaW1wbGVtZW50ZWQgJHtwYXJhbS50eXBlfSBvbiBUZW1wbGF0ZUNvbXBpbGVyYCk7XG4gICAgICAodGhpc1twYXJhbS50eXBlXSBhcyBhbnkpKHBhcmFtKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wY29kZShbJ3ByZXBhcmVBcnJheScsIHBhcmFtcy5sZW5ndGhdLCBudWxsKTtcbiAgfVxuXG4gIHByZXBhcmVIYXNoKGhhc2g6IEFTVC5IYXNoKSB7XG4gICAgbGV0IHBhaXJzID0gaGFzaC5wYWlycztcblxuICAgIGlmICghcGFpcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9wY29kZShbJ2xpdGVyYWwnLCBudWxsXSwgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IHBhaXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgeyBrZXksIHZhbHVlIH0gPSBwYWlyc1tpXTtcblxuICAgICAgYXNzZXJ0KHRoaXNbdmFsdWUudHlwZV0sIGBVbmltcGxlbWVudGVkICR7dmFsdWUudHlwZX0gb24gVGVtcGxhdGVDb21waWxlcmApO1xuICAgICAgKHRoaXNbdmFsdWUudHlwZV0gYXMgYW55KSh2YWx1ZSk7XG4gICAgICB0aGlzLm9wY29kZShbJ2xpdGVyYWwnLCBrZXldLCBudWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wY29kZShbJ3ByZXBhcmVPYmplY3QnLCBwYWlycy5sZW5ndGhdLCBudWxsKTtcbiAgfVxuXG4gIHByZXBhcmVBdHRyaWJ1dGVWYWx1ZSh2YWx1ZTogQVNULkF0dHJOb2RlWyd2YWx1ZSddKSB7XG4gICAgLy8gcmV0dXJucyB0aGUgc3RhdGljIHZhbHVlIGlmIHRoZSB2YWx1ZSBpcyBzdGF0aWNcblxuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgY2FzZSAnVGV4dE5vZGUnOlxuICAgICAgICB0aGlzLm9wY29kZShbJ2xpdGVyYWwnLCB2YWx1ZS5jaGFyc10sIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTXVzdGFjaGUoW3ZhbHVlXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgJ0NvbmNhdFN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMucHJlcGFyZUNvbmNhdFBhcnRzKHZhbHVlLnBhcnRzKTtcbiAgICAgICAgdGhpcy5vcGNvZGUoWydjb25jYXQnLCBudWxsXSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJlcGFyZUNvbmNhdFBhcnRzKHBhcnRzOiBBU1QuQ29uY2F0U3RhdGVtZW50WydwYXJ0cyddKSB7XG4gICAgZm9yIChsZXQgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICBpZiAocGFydC50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTXVzdGFjaGUoW3BhcnRdKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSAnVGV4dE5vZGUnKSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKFsnbGl0ZXJhbCcsIHBhcnQuY2hhcnNdLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9wY29kZShbJ3ByZXBhcmVBcnJheScsIHBhcnRzLmxlbmd0aF0sIG51bGwpO1xuICB9XG5cbiAgYXR0cmlidXRlTXVzdGFjaGUoW2FjdGlvbl06IFtBU1QuTXVzdGFjaGVTdGF0ZW1lbnRdKSB7XG4gICAgdGhpcy5tdXN0YWNoZUV4cHJlc3Npb24oYWN0aW9uKTtcbiAgfVxuXG4gIG1ldGEobm9kZTogQVNULkJhc2VOb2RlKSB7XG4gICAgbGV0IGxvYyA9IG5vZGUubG9jO1xuICAgIGlmICghbG9jKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IHsgc291cmNlLCBzdGFydCwgZW5kIH0gPSBsb2M7XG4gICAgcmV0dXJuIFsnbG9jJywgW3NvdXJjZSB8fCBudWxsLCBbc3RhcnQubGluZSwgc3RhcnQuY29sdW1uXSwgW2VuZC5saW5lLCBlbmQuY29sdW1uXV1dO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSGVscGVySW52b2NhdGlvbihcbiAgbXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudFxuKTogbXVzdGFjaGUgaXMgQVNULk11c3RhY2hlU3RhdGVtZW50ICYgeyBwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb24gfSB7XG4gIHJldHVybiAoXG4gICAgKG11c3RhY2hlLnBhcmFtcyAmJiBtdXN0YWNoZS5wYXJhbXMubGVuZ3RoID4gMCkgfHxcbiAgICAobXVzdGFjaGUuaGFzaCAmJiBtdXN0YWNoZS5oYXNoLnBhaXJzLmxlbmd0aCA+IDApXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlUGF0aCh7IHBhcnRzIH06IEFTVC5QYXRoRXhwcmVzc2lvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAxO1xufVxuXG5mdW5jdGlvbiBpc1lpZWxkKHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbikge1xuICByZXR1cm4gcGF0aC5vcmlnaW5hbCA9PT0gJ3lpZWxkJztcbn1cblxuZnVuY3Rpb24gaXNQYXJ0aWFsKHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbikge1xuICByZXR1cm4gcGF0aC5vcmlnaW5hbCA9PT0gJ3BhcnRpYWwnO1xufVxuXG5mdW5jdGlvbiBpc0RlYnVnZ2VyKHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbikge1xuICByZXR1cm4gcGF0aC5vcmlnaW5hbCA9PT0gJ2RlYnVnZ2VyJztcbn1cblxuZnVuY3Rpb24gaXNIYXNCbG9jayhwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb24pIHtcbiAgcmV0dXJuIHBhdGgub3JpZ2luYWwgPT09ICdoYXMtYmxvY2snO1xufVxuXG5mdW5jdGlvbiBpc0hhc0Jsb2NrUGFyYW1zKHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbikge1xuICByZXR1cm4gcGF0aC5vcmlnaW5hbCA9PT0gJ2hhcy1ibG9jay1wYXJhbXMnO1xufVxuXG5mdW5jdGlvbiBpc0J1aWx0SW5IZWxwZXIocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKSB7XG4gIHJldHVybiBpc0hhc0Jsb2NrKHBhdGgpIHx8IGlzSGFzQmxvY2tQYXJhbXMocGF0aCk7XG59XG5cbmZ1bmN0aW9uIGlzQXJnKHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gISFwYXRoWydkYXRhJ107XG59XG5cbmZ1bmN0aW9uIGlzRHluYW1pY0NvbXBvbmVudChlbGVtZW50OiBBU1QuRWxlbWVudE5vZGUpOiBib29sZWFuIHtcbiAgbGV0IG9wZW4gPSBlbGVtZW50LnRhZy5jaGFyQXQoMCk7XG5cbiAgbGV0IFttYXliZUxvY2FsXSA9IGVsZW1lbnQudGFnLnNwbGl0KCcuJyk7XG4gIGxldCBpc05hbWVkQXJndW1lbnQgPSBvcGVuID09PSAnQCc7XG4gIGxldCBpc0xvY2FsID0gZWxlbWVudFsnc3ltYm9scyddLmhhcyhtYXliZUxvY2FsKTtcbiAgbGV0IGlzVGhpc1BhdGggPSBlbGVtZW50LnRhZy5pbmRleE9mKCd0aGlzLicpID09PSAwO1xuXG4gIHJldHVybiBpc0xvY2FsIHx8IGlzTmFtZWRBcmd1bWVudCB8fCBpc1RoaXNQYXRoO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBvbmVudChlbGVtZW50OiBBU1QuRWxlbWVudE5vZGUpOiBib29sZWFuIHtcbiAgbGV0IG9wZW4gPSBlbGVtZW50LnRhZy5jaGFyQXQoMCk7XG4gIGxldCBpc1BhdGggPSBlbGVtZW50LnRhZy5pbmRleE9mKCcuJykgPiAtMTtcblxuICBsZXQgaXNVcHBlckNhc2UgPSBvcGVuID09PSBvcGVuLnRvVXBwZXJDYXNlKCkgJiYgb3BlbiAhPT0gb3Blbi50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiAoaXNVcHBlckNhc2UgJiYgIWlzUGF0aCkgfHwgaXNEeW5hbWljQ29tcG9uZW50KGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc1NpbXBsZVBhdGgocGF0aDogQVNULlBhdGhFeHByZXNzaW9uLCBsb2M6IEFTVC5Tb3VyY2VMb2NhdGlvbiwgY29udGV4dDogc3RyaW5nKSB7XG4gIGlmICghaXNTaW1wbGVQYXRoKHBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYFxcYCR7cGF0aC5vcmlnaW5hbH1cXGAgaXMgbm90IGEgdmFsaWQgbmFtZSBmb3IgYSAke2NvbnRleHR9IG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCxcbiAgICAgIHBhdGgubG9jXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFlpZWxkKHN0YXRlbWVudDogQVNULk11c3RhY2hlU3RhdGVtZW50KTogc3RyaW5nIHtcbiAgbGV0IHsgcGFpcnMgfSA9IHN0YXRlbWVudC5oYXNoO1xuXG4gIGlmICgocGFpcnMubGVuZ3RoID09PSAxICYmIHBhaXJzWzBdLmtleSAhPT0gJ3RvJykgfHwgcGFpcnMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgeWllbGQgb25seSB0YWtlcyBhIHNpbmdsZSBuYW1lZCBhcmd1bWVudDogJ3RvJ2AsIHN0YXRlbWVudC5sb2MpO1xuICB9IGVsc2UgaWYgKHBhaXJzLmxlbmd0aCA9PT0gMSAmJiBwYWlyc1swXS52YWx1ZS50eXBlICE9PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYHlvdSBjYW4gb25seSB5aWVsZCB0byBhIGxpdGVyYWwgdmFsdWVgLCBzdGF0ZW1lbnQubG9jKTtcbiAgfSBlbHNlIGlmIChwYWlycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAocGFpcnNbMF0udmFsdWUgYXMgQVNULlN0cmluZ0xpdGVyYWwpLnZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUGFydGlhbChzdGF0ZW1lbnQ6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkgLyogOiBleHByICovIHtcbiAgbGV0IHsgcGFyYW1zLCBoYXNoLCBlc2NhcGVkLCBsb2MgfSA9IHN0YXRlbWVudDtcblxuICBpZiAocGFyYW1zICYmIHBhcmFtcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgUGFydGlhbCBmb3VuZCB3aXRoIG5vIGFyZ3VtZW50cy4gWW91IG11c3Qgc3BlY2lmeSBhIHRlbXBsYXRlIG5hbWUuIChvbiBsaW5lICR7XG4gICAgICAgIGxvYy5zdGFydC5saW5lXG4gICAgICB9KWAsXG4gICAgICBzdGF0ZW1lbnQubG9jXG4gICAgKTtcbiAgfSBlbHNlIGlmIChoYXNoICYmIGhhc2gucGFpcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBwYXJ0aWFsIGRvZXMgbm90IHRha2UgYW55IG5hbWVkIGFyZ3VtZW50cyAob24gbGluZSAke2xvYy5zdGFydC5saW5lfSlgLFxuICAgICAgc3RhdGVtZW50LmxvY1xuICAgICk7XG4gIH0gZWxzZSBpZiAoIWVzY2FwZWQpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBge3t7cGFydGlhbCAuLi59fX0gaXMgbm90IHN1cHBvcnRlZCwgcGxlYXNlIHVzZSB7e3BhcnRpYWwgLi4ufX0gaW5zdGVhZCAob24gbGluZSAke1xuICAgICAgICBsb2Muc3RhcnQubGluZVxuICAgICAgfSlgLFxuICAgICAgc3RhdGVtZW50LmxvY1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZEhhc0Jsb2NrVXNhZ2UodHlwZTogc3RyaW5nLCBjYWxsOiBBU1QuQ2FsbCk6IHN0cmluZyB7XG4gIGxldCB7IHBhcmFtcywgaGFzaCwgbG9jIH0gPSBjYWxsO1xuXG4gIGlmIChoYXNoICYmIGhhc2gucGFpcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgJHt0eXBlfSBkb2VzIG5vdCB0YWtlIGFueSBuYW1lZCBhcmd1bWVudHNgLCBjYWxsLmxvYyk7XG4gIH1cblxuICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnZGVmYXVsdCc7XG4gIH0gZWxzZSBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgIGxldCBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgICByZXR1cm4gcGFyYW0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgYHlvdSBjYW4gb25seSB5aWVsZCB0byBhIGxpdGVyYWwgdmFsdWUgKG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0pYCxcbiAgICAgICAgY2FsbC5sb2NcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGAke3R5cGV9IG9ubHkgdGFrZXMgYSBzaW5nbGUgcG9zaXRpb25hbCBhcmd1bWVudCAob24gbGluZSAke2xvYy5zdGFydC5saW5lfSlgLFxuICAgICAgY2FsbC5sb2NcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkRGVidWdnZXJVc2FnZShzdGF0ZW1lbnQ6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICBsZXQgeyBwYXJhbXMsIGhhc2ggfSA9IHN0YXRlbWVudDtcblxuICBpZiAoaGFzaCAmJiBoYXNoLnBhaXJzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYGRlYnVnZ2VyIGRvZXMgbm90IHRha2UgYW55IG5hbWVkIGFyZ3VtZW50c2AsIHN0YXRlbWVudC5sb2MpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgZGVidWdnZXIgZG9lcyBub3QgdGFrZSBhbnkgcG9zaXRpb25hbCBhcmd1bWVudHNgLCBzdGF0ZW1lbnQubG9jKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgcHJlcHJvY2VzcyB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgVGVtcGxhdGVDb21waWxlciwgeyBDb21waWxlT3B0aW9ucyB9IGZyb20gJy4vdGVtcGxhdGUtY29tcGlsZXInO1xuaW1wb3J0IHtcbiAgU2VyaWFsaXplZFRlbXBsYXRlV2l0aExhenlCbG9jayxcbiAgVGVtcGxhdGVKYXZhc2NyaXB0LFxuICBUZW1wbGF0ZU1ldGEsXG59IGZyb20gJ0BnbGltbWVyL3dpcmUtZm9ybWF0JztcbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUHJlcHJvY2Vzc09wdGlvbnMgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlSWRGbiB7XG4gIChzcmM6IHN0cmluZyk6IE9wdGlvbjxzdHJpbmc+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZWNvbXBpbGVPcHRpb25zIGV4dGVuZHMgQ29tcGlsZU9wdGlvbnMsIFByZXByb2Nlc3NPcHRpb25zIHtcbiAgaWQ/OiBUZW1wbGF0ZUlkRm47XG59XG5cbmRlY2xhcmUgZnVuY3Rpb24gcmVxdWlyZShpZDogc3RyaW5nKTogYW55O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdElkOiBUZW1wbGF0ZUlkRm4gPSAoKCkgPT4ge1xuICBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tcmVxdWlyZS1pbXBvcnRzICovXG4gICAgICBjb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICAgIC8qIHRzbGludDplbmFibGU6bm8tcmVxdWlyZS1pbXBvcnRzICovXG5cbiAgICAgIGxldCBpZEZuOiBUZW1wbGF0ZUlkRm4gPSBzcmMgPT4ge1xuICAgICAgICBsZXQgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgICAgIGhhc2gudXBkYXRlKHNyYywgJ3V0ZjgnKTtcbiAgICAgICAgLy8gdHJpbSB0byA2IGJ5dGVzIG9mIGRhdGEgKDJeNDggLSAxKVxuICAgICAgICByZXR1cm4gaGFzaC5kaWdlc3QoJ2Jhc2U2NCcpLnN1YnN0cmluZygwLCA4KTtcbiAgICAgIH07XG5cbiAgICAgIGlkRm4oJ3Rlc3QnKTtcblxuICAgICAgcmV0dXJuIGlkRm47XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBpZEZuKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xufSkoKTtcblxuY29uc3QgZGVmYXVsdE9wdGlvbnM6IFByZWNvbXBpbGVPcHRpb25zID0ge1xuICBpZDogZGVmYXVsdElkLFxuICBtZXRhOiB7fSxcbn07XG5cbi8qXG4gKiBDb21waWxlIGEgc3RyaW5nIGludG8gYSB0ZW1wbGF0ZSBqYXZhc2NyaXB0IHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogICAgIGltcG9ydCB7IHByZWNvbXBpbGUgfSBmcm9tICdAZ2xpbW1lci9jb21waWxlcic7XG4gKiAgICAgaW1wb3J0IHsgdGVtcGxhdGVGYWN0b3J5IH0gZnJvbSAnZ2xpbWVyLXJ1bnRpbWUnO1xuICogICAgIGxldCB0ZW1wbGF0ZUpzID0gcHJlY29tcGlsZShcIkhvd2R5IHt7bmFtZX19XCIpO1xuICogICAgIGxldCBmYWN0b3J5ID0gdGVtcGxhdGVGYWN0b3J5KG5ldyBGdW5jdGlvbihcInJldHVybiBcIiArIHRlbXBsYXRlSnMpKCkpO1xuICogICAgIGxldCB0ZW1wbGF0ZSA9IGZhY3RvcnkuY3JlYXRlKGVudik7XG4gKlxuICogQG1ldGhvZCBwcmVjb21waWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIGEgR2xpbW1lciB0ZW1wbGF0ZSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gYSB0ZW1wbGF0ZSBqYXZhc2NyaXB0IHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlY29tcGlsZShzdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IFByZWNvbXBpbGVPcHRpb25zKTogVGVtcGxhdGVKYXZhc2NyaXB0O1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXBpbGUoXG4gIHN0cmluZzogc3RyaW5nLFxuICBvcHRpb25zOiBQcmVjb21waWxlT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zXG4pOiBUZW1wbGF0ZUphdmFzY3JpcHQge1xuICBsZXQgYXN0ID0gcHJlcHJvY2VzcyhzdHJpbmcsIG9wdGlvbnMpO1xuICBsZXQgeyBtZXRhIH0gPSBvcHRpb25zO1xuICBsZXQgeyBibG9jayB9ID0gVGVtcGxhdGVDb21waWxlci5jb21waWxlKGFzdCwgb3B0aW9ucyk7XG4gIGxldCBpZEZuID0gb3B0aW9ucy5pZCB8fCBkZWZhdWx0SWQ7XG4gIGxldCBibG9ja0pTT04gPSBKU09OLnN0cmluZ2lmeShibG9jay50b0pTT04oKSk7XG4gIGxldCB0ZW1wbGF0ZUpTT05PYmplY3Q6IFNlcmlhbGl6ZWRUZW1wbGF0ZVdpdGhMYXp5QmxvY2s8VGVtcGxhdGVNZXRhPiA9IHtcbiAgICBpZDogaWRGbihKU09OLnN0cmluZ2lmeShtZXRhKSArIGJsb2NrSlNPTiksXG4gICAgYmxvY2s6IGJsb2NrSlNPTixcbiAgICBtZXRhOiBtZXRhIGFzIFRlbXBsYXRlTWV0YSxcbiAgfTtcblxuICAvLyBKU09OIGlzIGphdmFzY3JpcHRcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlSlNPTk9iamVjdCk7XG59XG4iXSwibmFtZXMiOlsiZGljdCIsInVucmVhY2hhYmxlIiwiRGljdFNldCIsImlzRmx1c2hFbGVtZW50IiwiaXNBcmd1bWVudCIsImlzQXR0cmlidXRlIiwiaXNBdHRyU3BsYXQiLCJTdGFjayIsIk9wcyIsImlzTGl0ZXJhbCIsIlN5bnRheEVycm9yIiwicHJlcHJvY2VzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUEsSUFHRTs7Ozs7Z0JBQU8scUJBQ0w7ZUFBTyxJQUFJOzs7aURBYVA7OztZQUNBLGlCQUFpQjttQkFBWSxNQUFLLFNBQVM7U0FBakM7ZUFDUCxJQUFJLGlCQUFpQixNQUFNLFFBQVE7Ozs7O0FBSTlDLElBQWdDOzs7Ozs7K0VBQ3ZCOztlQUFPLFVBQWE7ZUFFZixPQUFHO2VBQ0YsUUFBR0E7ZUFDRixTQUFHQTs7OztvREFFYixPQUNGO2VBQU87OztvREFHTCxPQUNGO2NBQU1DOzs7d0VBSU47ZUFBTzs7O3NFQUlQO2VBQU87Ozt3RUFHSyxNQUNaO1lBQUksUUFBUSxLQUFLLE1BQU07WUFFbkIsQ0FBQyxPQUFPO29CQUNGLEtBQUssTUFBTSxRQUFRLEtBQUssU0FBUzs7ZUFHcEM7Ozt3RUFHSyxNQUNaO1lBQUksUUFBUSxLQUFLLE9BQU87WUFFcEIsQ0FBQyxPQUFPO29CQUNGLEtBQUssT0FBTyxRQUFRLEtBQUssZUFBYTs7ZUFHekM7Ozs4REFHQSxZQUNQO2FBQUssUUFBUSxLQUFLO2VBQ1gsS0FBSzs7OztFQTdDaEI7QUFpREEsSUFBOEI7Ozs4QkFDUixRQUE0QixTQUEwQjs7O3NEQUF0RDs7ZUFBTSxTQUFOO2VBQW1DLFVBQVA7ZUFBK0IsUUFBTDs7OztrREFJdEUsTUFDRjtlQUFPLEtBQUssUUFBUSxRQUFRLFVBQVUsQ0FBQyxLQUFLLEtBQUssT0FBTyxJQUFJOzs7a0RBRzFELE1BQ0Y7WUFBSSxPQUFPLEtBQUssUUFBUSxRQUFRO2VBQ3pCLFNBQVMsQ0FBQyxJQUFJLEtBQUssT0FBTyxJQUFJLFFBQVEsS0FBSyxNQUFNOzs7Ozs7WUFJcERELFVBQU8sS0FBSyxPQUFPO2FBQ2xCLFFBQVE7bUJBQW1CQSxRQUFLLFVBQVUsT0FBSyxJQUFJOztlQUNqREE7OztvRUFJUDtZQUFJLFNBQVMsS0FBSztzQkFDSixLQUFLLFFBQVE7bUJBQWMsT0FBTztTQUF6Qzs7O3NFQUdLLE1BQ1o7ZUFBTyxLQUFLLE9BQU8sY0FBYzs7O3NFQUdyQixNQUNaO2VBQU8sS0FBSyxPQUFPLGNBQWM7Ozs0REFHMUIsWUFDUDtlQUFPLEtBQUssT0FBTyxTQUFTOzs7O0VBbENNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF3RnRDOzs7U0FDbUIsYUFBbUI7U0FDckIsV0FBdUI7U0FDckIsYUFBbUI7U0FDbkIsYUFBbUI7U0FDWCxxQkFBRztTQUNSLGdCQUFHO1NBQ1QsVUFBYTtTQUNELHNCQUFxQjtTQUNqQyxVQUF3Qjs7O0lBaUN4Qzs7OzthQUNvQixhQUFZO2FBQ2hCLFVBQWE7YUFDUCxlQUFHLENBQUM7OztxREFFbEIsTUFDSjthQUFLLEtBQUssTUFBTTs7Ozs7eURBS1Y7OzthQUNEO1lBRUQsY0FBYyxLQUFLO1lBQ25CLGVBQWUsS0FBSztZQUVwQixDQUFDLGFBQWE7b0JBQ1IsYUFBYSxZQUFZO2VBQzVCO29CQUNHLGFBQWEsWUFBWSxRQUFTLE1BQU0sUUFBUTs7WUFHdEQ7WUFBbUI7WUFFbkIsS0FBSyxpQkFBaUIsR0FBRzt3QkFDZjtzQkFDRjtlQUNMO3dCQUNPO3NCQUNGOztxQkFHQyxhQUFhO3FCQUNiLFdBQVcsUUFBUTtxQkFDbkIsYUFBYSxRQUFRLEtBQUs7cUJBQzFCLHNCQUFzQjtxQkFDdEIsUUFBUSxLQUFLLENBQUMsU0FBUyxDQUFDLFNBQVMsS0FBSztxQkFDdEMsVUFBVSxRQUFRO2FBRTFCLElBQUksSUFBSSxRQUFRLEtBQUssU0FBUyxHQUFHLEtBQUssR0FBRyxLQUFLO3lCQUNwQyxhQUFhO2lCQUNyQixNQUFNLFFBQVEsS0FBSzs7cUJBR2IsUUFBUSxLQUFLLENBQ3hCLFdBQ0EsQ0FBQyxTQUFTLGFBQWEsb0JBQW9CLGFBQWEsb0JBQW9CO2FBRXpFO2FBRUE7O1lBR0QsYUFBYTt3QkFDSDs7eUJBRVQsU0FBUSxxQkFBUSxhQUFhLFFBQVE7OztpRUFHaEM7OztZQUNOLGNBQWMsS0FBSztZQUNuQixlQUFlLEtBQUs7cUJBRVgsYUFBYTtxQkFDYixXQUFXLFFBQVE7cUJBQ25CLGFBQWEsUUFBUSxTQUFTO3FCQUM5QixpQkFBaUIsUUFBUSxVQUFVO3FCQUNuQyxzQkFBc0I7cUJBQ3RCLFVBQVUsUUFBUSxhQUFhLFlBQVksUUFBUyxNQUFNLFFBQVE7WUFFM0UsYUFBZ0QsQ0FDbEQsU0FDQSxZQUFZLFlBQ1osWUFBWTtxQkFHRCxRQUFRLEtBQUssQ0FBQyxnQkFBZ0I7YUFFdEMsSUFBSSxJQUFJLFFBQVEsV0FBVyxTQUFTLEdBQUcsS0FBSyxHQUFHLEtBQUs7aUJBQ2xELE1BQU0sUUFBUSxXQUFXOzthQUczQixJQUFJLEtBQUksUUFBUSxTQUFTLFNBQVMsR0FBRyxNQUFLLEdBQUcsTUFBSzt5QkFDeEMsYUFBYTtpQkFDckIsTUFBTSxRQUFRLFNBQVM7O1lBRzFCLE9BQU8sQ0FDVCx5QkFDSSxhQUFZLGFBQWEsZUFBZSxhQUFhLG9CQUFvQjtxQkFFbEUsUUFBUSxLQUFLO2FBRXJCOztZQUdELGFBQWEsZ0JBQWdCLEdBQUc7d0JBQ3RCOztvQkFFRixzQkFBc0IsYUFBYTs0Q0FDbkMsU0FBUSxpQ0FBUSxhQUFhOzs7MkRBR2xDLE1BQ1A7WUFBSSxLQUFLLE1BQU0sU0FBUyxZQUFZO2lCQUM3QixhQUFhOzs7OzJEQUliLE1BQ1A7WUFBSSxRQUFRLEtBQUs7WUFDYixLQUFLLFVBQVUsSUFBSTtrQkFDZixvQkFBcUIsS0FBSyxXQUFXLE1BQU0sVUFBVzs7Y0FFeEQsUUFBUSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sTUFBTSxZQUFZLE1BQU07Ozt1RUFHOUMsTUFDYjtZQUFJLFFBQVEsS0FBSztjQUVYO2NBQ0EsUUFBUSxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sTUFBTSxZQUFZLE1BQU07WUFFeEQsS0FBSyxTQUFTO2lCQUNYLE1BQU0sS0FBSzs7WUFFZCxLQUFLLFNBQVM7aUJBQ1gsTUFBTSxLQUFLOzs7OzJFQUlILE1BQ2Y7WUFBSSxRQUFRLEtBQUs7Y0FDWDtjQUNBLFFBQVEsS0FBSyxDQUFDLFlBQVksQ0FBQyxNQUFNLE1BQU0sWUFBWSxNQUFNOzs7MkVBR2hELE1BQ2Y7WUFBSSxRQUFRLEtBQUs7Y0FDWCxRQUFRLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxNQUFNLFlBQVksTUFBTTs7OzZGQUk5RDs7Ozs2RUFHZ0IsVUFDaEI7WUFBSSxRQUFRLEtBQUs7Y0FDWDtjQUNBLFFBQVEsS0FBSyxDQUFDLFlBQVksQ0FBQyxVQUFVLE1BQU0sWUFBWSxNQUFNOzs7OzsyRUFVbkU7ZUFBTyxLQUFLLFdBQVcsS0FBSyxXQUFXLFNBQVM7OzsrREFJaEQ7WUFBSSxRQUFRLElBQUk7YUFDWCxXQUFXLEtBQUs7ZUFDZDs7OzZEQUlQO2VBQU8sS0FBSyxXQUFXOzs7Ozs0QkFkdkI7bUJBQWMsS0FBSzs7Ozs7O0FBa0J2QixBQUVBLG9CQUFvQixPQUFtQixTQUNyQztRQUFJLFFBQVEsQ0FBQztTQUVSLElBQUksSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7WUFDakMsT0FBTyxNQUFNO1lBRWIsS0FBSyxTQUFTLGNBQWMsS0FBSyxTQUFTLGVBQWU7O2VBRXREOzs7WUFJSCxTQUFTLFNBQVM7bUJBQ2I7OztXQUlKLENBQUM7Ozs7Ozs7Ozs7Ozs7QUM3WVYsSUEyQkE7Ozs7YUFDbUIsYUFBZ0I7Ozt5Q0FJNUIsV0FDSDthQUFLLFdBQVcsS0FBSzs7Ozs7QUFJekIsSUFBeUI7Ozt5QkFDSjs7O3VEQUFBOztjQUFLLFFBQUw7Ozs7cURBS2pCOzt3QkFDYyxLQUFLO3dCQUNMLEtBQUssTUFGWjs7Ozs7RUFOc0I7QUFhakMsSUFBMkI7OzsyQkFPTDs7O3dEQUFBOztlQUFXLGNBTnhCO2VBQUksT0FBRztlQUNELFNBQUcsSUFBSUU7ZUFDUixRQUFHLElBQUlBO2VBQ04sU0FBNEI7ZUFDM0IsVUFBRzs7OztpREFNWixXQUNIO2FBQUssV0FBVyxLQUFLOzs7dURBSXJCOztxQkFDVyxLQUFLLFlBQVk7d0JBQ2QsS0FBSztxQkFDUixLQUhKOzs7OztFQWhCd0I7QUF3Qm5DLElBQTRCOzs7NEJBTU4sS0FBcUIsT0FBaUM7Ozt3REFBdEQ7O2VBQUcsTUFBSDtlQUEwQixRQUFMO2VBQTRDLGNBTDlFO2VBQVUsYUFBMkI7ZUFDNUIsWUFBMEI7ZUFDMUIsV0FBRztlQUNELGNBQWE7Ozs7a0RBTTFCLFdBQ0g7WUFBSSxLQUFLLFVBQVU7Z0JBQ2JDLDBCQUFlLFlBQVk7cUJBQ3hCLFdBQVc7dUJBQ1BDLHNCQUFXLFlBQVk7cUJBQzNCLFVBQVUsS0FBSzt1QkFDWEMsdUJBQVksWUFBWTtxQkFDNUIsV0FBVyxLQUFLO3VCQUNaQyx1QkFBWSxZQUFZO3FCQUM1QixXQUFXLEtBQUs7bUJBQ2hCO3NCQUNDLElBQUksTUFBTTs7ZUFFYjtpQkFDQSxXQUFXLEtBQUs7Ozs7d0RBS3ZCO1lBQUksT0FBTyxLQUFLO1lBQ1osWUFBWTttQkFBVyxJQUFJO1NBQXBCO1lBQ1AsY0FBYzttQkFBVyxJQUFJO1NBQXBCO1lBQ1QsUUFBUSxLQUFLLGNBQ2I7d0JBRWMsS0FBSzt3QkFDTCxLQUFLLE1BRm5COztlQUtHLENBQUMsS0FBSyxLQUFLLEtBQUssWUFBWSxDQUFDLE1BQU0sU0FBUzs7OztFQXZDbkI7QUEyQ3BDLElBR0U7c0JBQVk7OzthQUNMLFFBQVEsSUFBSSxjQUFjOzs7a0RBSS9CO2VBQU8sS0FBSyxNQUFNOzs7Ozs7SUF3QnBCO2dDQUFZLFNBQWlCLFNBQTZCOzs7YUFMNUMsU0FBRyxJQUFJQzthQUVQLFNBQWlCO2FBSXhCLFVBQVU7YUFDVixXQUFXLElBQUksU0FBUzthQUN4QixVQUFVOzs7dUJBZFYsMkJBQVEsU0FBaUIsU0FBNkIsU0FDM0Q7WUFBSSxXQUFXLElBQUksbUJBQW1CLFNBQVMsU0FBUztlQUNqRCxTQUFTOzs7Ozs7YUFvQlgsUUFBUSxRQUFRLGNBQ25CO2dCQUFJLFNBQVMsR0FBRztnQkFDWixNQUFNLEdBQUc7Z0JBRVQsQ0FBQyxPQUFLLFNBQVM7c0JBQ1gsSUFBSSx5QkFBdUI7O21CQUU3QixRQUFnQjs7ZUFHakIsS0FBSzs7Ozs7a0VBS0gsU0FDVDtZQUFJLFFBQWUsSUFBSSxZQUFZLFFBQVE7YUFDdEMsT0FBTyxLQUFLOzs7O1lBSVg7WUFBVSxTQUFXOztZQUN2QixRQUFRLE9BQU87aUJBQ1YsTUFBTSxPQUFPLEtBQUssTUFBTTs7O3dFQUlqQzthQUFLLE9BQU8sS0FBSyxLQUFLLFNBQVM7OztvRUFHbkI7Ozs7c0RBSVQsU0FDSDthQUFLLEtBQUssQ0FBQ0MsZUFBSSxNQUFNOzs7MERBR2hCLFNBQ0w7YUFBSyxLQUFLLENBQUNBLGVBQUksUUFBUSxLQUFLLFlBQXdCOzs7NERBRzlDLE9BQ047YUFBSyxLQUFLLENBQUNBLGVBQUksU0FBUzs7OzhEQUdqQixNQUNQO1lBQUksU0FBUyxLQUFLO1lBQ2QsT0FBTyxLQUFLO2FBRVgsS0FBSyxDQUFDQSxlQUFJLFVBQVUsTUFBTSxRQUFROzs7aUNBR25DO1lBQUM7WUFBTTtZQUFVOztZQUNqQixTQUFTLEtBQUs7WUFDZCxPQUFPLEtBQUs7WUFFWixTQUFTLEtBQUssU0FBUyxNQUFNO2FBVTVCLEtBQUssQ0FBQ0EsZUFBSSxPQUFPLE1BQU0sUUFBUSxNQUFNLE9BQU8sV0FBVyxPQUFPOzs7d0VBR3ZELFNBQ1o7WUFBSSxNQUNGLEtBQUssV0FBVyxLQUFLLFFBQVEseUJBQ3pCLEtBQUssUUFBUSx1QkFBdUIsUUFBUSxPQUM1QyxRQUFRO1lBQ1YsWUFBWSxJQUFJLGVBQWUsS0FBSyxRQUFRLFlBQVksUUFBUTthQUMvRCxPQUFPLEtBQUs7OztvRkFHQyxTQUNsQjtZQUFJLE1BQU0sUUFBUTtZQUVkLFFBQVEsWUFBWSxTQUFTLEdBQUc7a0JBQzVCLElBQUksMkJBQ1csUUFBUTtlQUV4QjtpQkFDQSxLQUFLLENBQUNBLGVBQUkscUJBQXFCOzs7O29FQUk1QixTQUNWO1lBQUksTUFBTSxRQUFRO1lBRWQsUUFBUSxZQUFZLFNBQVMsR0FBRztrQkFDNUIsSUFBSSwyQkFDVyxRQUFRO2VBRXhCO2lCQUNBLEtBQUssQ0FBQ0EsZUFBSSxhQUFhOzs7O3dFQUs5QjthQUFLLEtBQUssQ0FBQ0EsZUFBSTs7OzBFQUdGO1lBQ1QsU0FBUyxVQUFVLFNBQVMsR0FBRztrQkFDM0IsSUFBSSxNQUFNOzs7NEJBRWMsS0FBSztZQUFoQztZQUFLO1lBQU87WUFBTTs7YUFFbEIsS0FBSyxDQUFDQSxlQUFJLFdBQVcsS0FBSyxPQUFPLE1BQU07Ozt3RkFHeEI7NkJBQ1MsS0FBSztZQUEzQjtZQUFPO1lBQU07O2FBRWYsS0FBSyxDQUFDQSxlQUFJLGtCQUFrQixLQUFLLFlBQXdCLE9BQU8sTUFBTTs7O3NFQUdoRSxVQUNYO2FBQUssS0FBSyxDQUFDQSxlQUFJOzs7aUNBR047WUFBQztZQUFNOztZQUNaLFFBQVEsS0FBSzthQUNaLEtBQUssQ0FBQ0EsZUFBSSxZQUFZLE1BQU0sT0FBTzs7O2lDQUc5QjtZQUFDO1lBQU07O1lBQ2IsUUFBUSxLQUFLO2FBQ1osS0FBSyxDQUFDQSxlQUFJLGFBQWEsTUFBTSxPQUFPOzs7aUNBRzlCO1lBQUM7WUFBTTs7WUFDZCxRQUFRLEtBQUs7YUFDWixLQUFLLENBQUNBLGVBQUksY0FBYyxNQUFNLE9BQU87OztnRUFHbEMsTUFDUjtZQUFJLFFBQVEsS0FBSzthQUNaLEtBQUssQ0FBQ0EsZUFBSSxXQUFXLE1BQU07OztrRUFHdkIsTUFDVDtZQUFJLFFBQVEsS0FBSzthQUNaLEtBQUssQ0FBQ0EsZUFBSSxZQUFZLE1BQU07Ozt5REFHN0IsSUFDSjtZQUFJLFNBQVMsS0FBSzthQUNiLEtBQUssQ0FBQ0EsZUFBSSxPQUFPLElBQUk7OztnRUFHbEIsSUFDUjthQUFLLEtBQUssQ0FBQ0EsZUFBSSxXQUFXOzs7K0RBR25CLFVBQ1A7YUFBSyxLQUFLLENBQUNBLGVBQUksVUFBVTthQUNwQixTQUFTLE1BQU0sVUFBVTs7OzhEQUd2QixNQUNQO2FBQUssVUFBZ0MsQ0FBQ0EsZUFBSSxVQUFVOzs7MEVBR3ZDLE1BQ2I7YUFBSyxVQUFzQyxDQUFDQSxlQUFJLGdCQUFnQjs7OzREQUcxRCxVQUNOO1lBQUksU0FBUyxLQUFLO2FBQ2IsS0FBSyxDQUFDQSxlQUFJLFNBQVMsT0FBTyxJQUFJO2FBQzlCLFNBQVMsTUFBTSxVQUFVOzs7Ozs0REFLeEIsT0FDTjtZQUFJLFVBQVUsV0FBVztpQkFDbEIsVUFBaUMsQ0FBQ0EsZUFBSTtlQUN0QztpQkFDQSxVQUE2Qjs7Ozs0REFJOUIsTUFDTjthQUFLLFVBQStCLENBQUNBLGVBQUksU0FBUzs7O2lDQUdoRDtZQUFDO1lBQU07O2FBQ0osVUFBMkIsQ0FBQ0EsZUFBSSxLQUFLLE1BQU07OztrRUFHdkMsTUFDVDthQUFLLFVBQWtDLENBQUNBLGVBQUksWUFBWTs7OzREQUl4RDthQUFLLFVBQThCLENBQUNBLGVBQUksUUFBUSxLQUFLOzs7MERBR2hELE1BQ0w7WUFBSSxTQUFTLEtBQUs7WUFDZCxPQUFPLEtBQUs7YUFFWCxVQUE4QixDQUFDQSxlQUFJLFFBQVEsTUFBTSxRQUFROzs7OztzRUFLbkQsTUFDWDtZQUFJLFNBQXVCO2FBRXRCLElBQUksSUFBSSxHQUFHLElBQUksTUFBTSxLQUFLO21CQUN0QixLQUFLLEtBQUs7O2FBR2QsVUFBa0I7Ozt3RUFHWDtZQU1SLE9BQWlCLElBQUksTUFBTTtZQUMzQixTQUF1QixJQUFJLE1BQU07YUFFaEMsSUFBSSxJQUFJLEdBQUcsSUFBSSxNQUFNLEtBQUs7aUJBQ3hCLEtBQUssS0FBSzttQkFDUixLQUFLLEtBQUs7O2FBR2QsVUFBZ0IsQ0FBQyxNQUFNOzs7Ozt3RUFNNUI7WUFBSSxZQUFZLEtBQUssT0FBTztlQU1wQixVQUE2Qjs7O3NEQUdsQyxNQUNIO2VBQU8sS0FBSyxLQUFLLFNBQVMsT0FBTyxNQUFNO2lCQUNoQzs7YUFHRixhQUFhLEtBQUs7OztnRUFHdUIsS0FDOUM7YUFBSyxPQUFPLEtBQUs7Ozs7ZUFLVixLQUFLLE9BQU87Ozs7OzRCQS9RbkI7bUJBQWMsS0FBSyxPQUFPOzs7Ozs7O0FDaEo5Qjs7Ozs7Ozs7Ozs7OztBQWNBLElBQU0sUUFBUTtBQUNkLElBQU0sTUFBTTtBQUNaLElBQU0sUUFBUTtBQUVkLElBQU07cUJBQ2E7cUJBQ0E7a0JBQ0g7a0JBQ0E7a0JBQ0E7bUJBQ0M7a0JBQ0Q7Z0JBQ0Y7Z0JBQ0E7aUJBQ0M7V0FDTjttQkFYUzs7QUFlbEIsMEJBQWlDLFVBQy9CO1dBQU8sVUFBVSxhQUFhOzs7Ozs7O0FDM0NoQyxJQXFCRTs2QkFBb0I7OzthQUFHLE1BRmY7YUFBVyxjQUFHLElBQUlEOzs7O1lBS3BCLE1BQWU7WUFDYixNQUFROzthQUVULElBQUksSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEtBQUs7Z0JBQy9CLEtBQUssSUFBSTtnQkFDVCxTQUFTLEtBQUssU0FBUztnQkFFdkIsV0FBVyxXQUFXO29CQUNwQixLQUFLO21CQUNKO29CQUNELEtBQUs7OztlQUlOOzs7MkRBR2dCLElBQ3ZCO1lBQUksT0FBTyxHQUFHO1lBQ1YsVUFBVSxHQUFHO2VBRVQsS0FBSyxNQUFjOzs7bUVBT2hCLElBQ1g7YUFBSyxZQUFZLEtBQUssR0FBRzs7OytEQUdoQixLQUNUO2FBQUssWUFBWTs7OytEQUdSLElBQ1Q7YUFBSyxZQUFZLEtBQUssR0FBRzs7OzJEQUdsQixLQUNQO2FBQUssWUFBWTs7O21FQUdOLElBQ1g7YUFBSyxZQUFZLEtBQUssR0FBRzs7O21FQUdkLEtBQ1g7YUFBSyxZQUFZOzs7dUVBR0osS0FDYjthQUFLLFlBQVk7OztxRkFHRyxLQUNwQjthQUFLLFlBQVk7Ozs2REFHVCxLQUNSO2VBQU8sQ0FBQyxhQUFhLEtBQUssUUFBUSxjQUFjOzs7aURBRzlDO1lBQ0csT0FBYztZQUFSOztZQUVQLFNBQVMsR0FBRzttQkFDUCxDQUFDLE9BQU8sQ0FBQyxHQUFHOztZQUdqQixRQUFRLE1BQU0sS0FBSyxVQUFVO2dCQUMzQixPQUFPLEtBQUssUUFBUSxJQUFJO21CQUNyQixDQUFDLE9BQU8sQ0FBQyxNQUFNO21CQUNiLEtBQUssT0FBTyxLQUFLO2dCQUN0QixRQUFPLEtBQUssUUFBUSxjQUFjO21CQUMvQixDQUFDLE9BQU8sQ0FBQyxPQUFNO2VBQ2pCO21CQUNFLENBQUMsZUFBZSxhQUFTOzs7OzJEQUkzQjtZQUNGLE9BQWM7WUFBUjs7WUFFUCxTQUFTLEdBQUc7bUJBQ1AsQ0FBQyxPQUFPLENBQUMsR0FBRzs7WUFHakIsUUFBUSxNQUFNLEtBQUssVUFBVTtnQkFDM0IsT0FBTyxLQUFLLFFBQVEsSUFBSTttQkFDckIsQ0FBQyxPQUFPLENBQUMsTUFBTTttQkFDYixLQUFLLE9BQU8sS0FBSztnQkFDdEIsU0FBTyxLQUFLLFFBQVEsY0FBYzttQkFDL0IsQ0FBQyxPQUFPLENBQUMsUUFBTTttQkFDYixLQUFLLFdBQVcsR0FBRzttQkFDckIsQ0FBQyxXQUFXO2VBQ2Q7bUJBQ0UsQ0FBQyxlQUFlLGFBQVM7Ozs7c0RBSTlCLElBQ0o7WUFBSSxPQUFPLEdBQUc7a0JBQ04sSUFBSSxNQUFNOztlQUdYLENBQUMsU0FBUyxLQUFLLFFBQVEsY0FBYzs7OzREQUdyQyxLQUNQO2VBQU8sQ0FBQyxZQUFZLEtBQUssUUFBUTs7OzJEQUcxQixJQUNQO1lBQUksT0FBTyxHQUFHO2tCQUNOLElBQUksTUFBTTs7ZUFHWCxDQUFDLFlBQVksS0FBSyxRQUFRLGNBQWM7Ozt1RUFHbEMsSUFDYjtZQUFJLE9BQU8sR0FBRztrQkFDTixJQUFJLE1BQU07O2VBR1gsQ0FBQyxrQkFBa0IsS0FBSyxRQUFRLGNBQWM7Ozt5REFHL0MsS0FDTjtlQUFPLENBQUMsV0FBVyxLQUFLLFFBQVE7OzttREFHN0IsS0FBYzs7eURBQ1gsS0FBYzs7cUVBQ1IsS0FBdUI7O2lFQUN6QixLQUF1Qjs7aUZBQ2YsS0FBdUI7OzZEQUNqQyxLQUFjOzsrREFDYixLQUFjOzsrREFDZCxLQUFnQzs7bUVBQzlCLEtBQWdDOztpRUFDakMsS0FBZ0M7OzJEQUNuQyxLQUFjOzt1REFDaEIsS0FBZTs7cURBQ2hCLEtBQXdDOzt5REFDdEMsS0FBb0Q7O3VEQUNyRCxLQUFjOzt5REFDYixLQUFjOzsrREFDWCxLQUFnQjs7bUVBQ2QsS0FBYzs7cUVBQ2IsS0FBYzs7dURBQ3JCLEtBQVk7Ozs7NEJBaElqQjttQkFBYyxLQUFLLFlBQVk7Ozs7OztBQW1JbkMsaUJBQWlCLE1BQWMsU0FDN0I7V0FBTyxXQUFXLFFBQVEsSUFBSTs7Ozs7QUN4TGhDLEFBY0Esd0JBQXdCLE9BQ3RCO1dBQU8sTUFBTSxZQUFZLGFBQWEsQ0FBQyxNQUFNOztBQUcvQzs7SUFFQTs7OzthQVlvQixhQUFHO2FBQ0YsY0FBYTthQUNqQixVQUFpQjthQUNiLGNBQUc7OztxQkFkZiwyQkFBUSxLQUFrQixTQUMvQjtZQUFJLGtCQUFrQixJQUFJO3dCQUNWLE1BQU07WUFFbEIsV0FBVyxJQUFJO1lBQ2YsVUFBd0IsU0FBUyxRQUFRLGdCQUFnQjtZQUN6RCxVQUF5QixJQUFJLGdCQUFnQixTQUFTO2VBRW5ELG1CQUFtQixRQUFRLFNBQVMsSUFBSSxZQUFZOzs7MERBUXJEOzs7Z0JBQ0UsUUFBUTtnQkFBRTtnQkFBUzs7Z0JBQ3JCLENBQUMsTUFBSyxPQUFPO3NCQUNULElBQUkseUJBQXVCOztrQkFFN0IsbUJBQWlCOztlQUVsQixLQUFLOzs7K0JBR0Q7WUFBQzs7YUFDUCxPQUFPLENBQUMsZ0JBQWdCLFVBQVU7OztrRUFJdkM7YUFBSyxPQUFPLENBQUMsY0FBYyxPQUFPOzs7K0JBR3pCO1lBQUM7O2FBQ0w7YUFDQSxPQUFPLENBQUMsY0FBYyxVQUFVOzs7OERBSXJDO2FBQUssWUFBWSxLQUFLLEtBQUssYUFBYTthQUNuQyxPQUFPLENBQUMsWUFBWSxPQUFPOzs7K0JBRzdCO1lBQUM7O2FBQ0MsT0FBTyxDQUFDLFFBQVEsT0FBTyxRQUFROzs7K0JBRzlCO1lBQUM7O2FBQ0YsT0FBTyxDQUFDLFdBQVcsT0FBTyxRQUFROzs7K0JBRzdCO1lBQUM7O1lBQ1AsYUFBYSxPQUFPO1lBQ3BCO2FBRUMsSUFBSSxJQUFJLEdBQUcsSUFBSSxXQUFXLFFBQVEsS0FBSztnQkFDdEMsT0FBTyxXQUFXO2dCQUNsQixLQUFLLFNBQVMsaUJBQWlCOzJCQUN0Qjs7OztZQUtYLG1CQUFtQjtnQkFDakI7Z0JBQWdCOztvQ0FDRixPQUFPLElBQUksTUFBTTs7Ozs7Z0JBQy9CLFNBQVMsUUFBUTt1QkFDWjs7aUJBRUosT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNO2lCQUN0QixPQUFPLENBQUMsaUJBQWlCLFNBQVM7bUJBQzlCLFlBQVksU0FBUztpQkFDekIsT0FBTyxDQUFDLGlCQUFpQixTQUFTO21CQUM5QixVQUFVO2lCQUNkLE9BQU8sQ0FBQyx1QkFBdUIsU0FBUztlQUN4QztpQkFDQSxPQUFPLENBQUMsZUFBZSxTQUFTOztZQUduQyxXQUFpQztZQUNqQyxRQUFRLE9BQU87YUFDZCxJQUFJLEtBQUksR0FBRyxLQUFJLE1BQU0sUUFBUSxNQUFLO2dCQUNqQyxNQUFNLElBQUcsU0FBUyxRQUFROzJCQUNqQixNQUFNOzs7aUJBR2QsVUFBVSxDQUFDLE1BQU07O1lBR3BCLFVBQVU7aUJBQ1AsVUFBVSxDQUFDOzthQUdiLE9BQU8sQ0FBQyxnQkFBZ0IsU0FBUzs7OytCQUczQjtZQUFDOztZQUNSLG1CQUFtQixTQUFTO2lCQUN6QixPQUFPLENBQUMseUJBQXlCLFNBQVM7bUJBQ3RDLFlBQVksU0FBUztpQkFDekIsT0FBTyxDQUFDLGtCQUFrQixTQUFTO21CQUMvQixPQUFPLFVBQVUsU0FBUyxHQUFHO2lCQUNqQyxJQUFJLElBQUksR0FBRyxJQUFJLE9BQU8sVUFBVSxRQUFRLEtBQUs7cUJBQzNDLFNBQVMsQ0FBQyxPQUFPLFVBQVU7O2lCQUU3QixPQUFPLENBQUMsZ0JBQWdCLFNBQVM7ZUFDakM7aUJBQ0EsT0FBTyxDQUFDLGdCQUFnQixTQUFTOzs7OytCQUloQztZQUFDO1lBQ0gsT0FBZ0I7WUFBVjs7WUFFUixZQUFZLGlCQUFpQjtZQUU3QixXQUFXLEtBQUssc0JBQXNCO1lBRXRDLEtBQUssT0FBTyxPQUFPLEtBQUs7O2dCQUV0QixVQUFVO3FCQUNQLE9BQU8sQ0FBQyxhQUFhLE9BQU87dUJBQ3hCLE9BQU8sTUFBTSxTQUFTLHFCQUFxQjtxQkFDL0MsT0FBTyxDQUFDLGNBQWMsT0FBTzttQkFDN0I7cUJBQ0EsT0FBTyxDQUFDLGNBQWMsT0FBTzs7ZUFFL0I7Z0JBQ0QsYUFBYSxlQUFlO2dCQUU1QixZQUFZLFNBQVMsaUJBQWlCO3FCQUNuQyxPQUFPLENBQUMsYUFBYSxPQUFPO3VCQUN4QixVQUFVO3FCQUNkLE9BQU8sQ0FBQyxjQUFjLENBQUMsTUFBTSxhQUFhO3VCQUN0QyxZQUFZO3FCQUNoQixPQUFPLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxhQUFhO3VCQUN4QyxPQUFPLE1BQU0sU0FBUyxxQkFBcUI7cUJBQy9DLE9BQU8sQ0FBQyxlQUFlLENBQUMsTUFBTSxRQUFRO21CQUN0QztxQkFDQSxPQUFPLENBQUMsZUFBZSxDQUFDLE1BQU0sYUFBYTs7Ozs7K0JBSzdDO1lBQUM7OzJCQUNXLE9BQU8sTUFBTSxPQUFPLEtBQUs7WUFHbEMsUUFDTixPQURGOzthQUdHLGNBQWM7YUFDZCxPQUFPLENBQUMsWUFBWSxNQUFNLEtBQUs7OzsrQkFHN0I7WUFBQztZQUNGLE9BQVM7O1lBRVhFLGlCQUFVLE9BQU87aUJBQ2QsbUJBQW1CO2lCQUNuQixPQUFPLENBQUMsVUFBVSxDQUFDLE9BQU8sVUFBVTttQkFDaEMsUUFBUSxPQUFPO2dCQUNwQixLQUFLLGlCQUFpQjtpQkFDckIsTUFBTSxJQUFJO21CQUNOLFVBQVUsT0FBTztnQkFDdEIsU0FBUyxtQkFBbUI7aUJBQzNCLFFBQVEsUUFBUTttQkFDWixXQUFXLE9BQU87cUNBQ0Y7aUJBQ3BCLFNBQVMsWUFBWTtlQUNyQjtpQkFDQSxtQkFBbUI7aUJBQ25CLE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxVQUFVOzs7OytCQUl2QztZQUFDOzthQUNBLGNBQWM7WUFDZixhQUFhLEtBQUssWUFBWTtZQUM5QixZQUFZLE9BQU8sWUFBWSxPQUFPLE9BQU8sS0FBSyxZQUFZO2FBQzdELE9BQU8sQ0FBQyxTQUFTLENBQUMsT0FBTyxLQUFLLE1BQU0sSUFBSSxZQUFZLGFBQWE7Ozs7OytCQUtwRTtZQUFDOzswQkFHQyxLQURGO1lBQVE7WUFBUzs7YUFFZCxPQUFPLENBQUMsT0FBTyxPQUFLLE1BQVEsUUFBUTs7O2dGQUd4QjtZQUNYLE9BQVM7O1lBRVhBLGlCQUFVLE9BQU87aUJBQ2QsT0FBTyxDQUFDLFdBQVcsS0FBSyxRQUFRO21CQUM1QixnQkFBZ0IsT0FBTztpQkFDM0IsY0FBYzttQkFDVixNQUFNLE9BQU87aUJBQ2pCLElBQUksQ0FBQzttQkFDRCxtQkFBbUIsT0FBTztpQkFDOUIsY0FBYztpQkFDZCxPQUFPLENBQUMsVUFBVSxLQUFLLE1BQU0sS0FBSzttQkFDOUIsS0FBSyxNQUFNO2lCQUNmLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLFNBQVM7OytCQUVmLEtBQUs7Z0JBQXZCO2dCQUFTOztpQkFDVCxPQUFPLENBQUMsWUFBWSxDQUFDLE1BQU0sU0FBUzs7Ozs7Ozs7Ozs7Ozs7dURBZXZDLElBQVksUUFDaEI7YUFBSyxjQUFjLE9BQU87YUFDckIsT0FBTyxDQUFDLFNBQVMsS0FBSzs7OzZEQUdwQixPQUFlLFFBQ3RCO2FBQUssT0FBTyxDQUFDLFlBQVksT0FBTzs7OzREQUd6QixNQUFjLFFBQ3JCO2FBQUssT0FBTyxDQUFDLFlBQVksT0FBTzs7O3dFQUduQixNQUFjLFFBQzNCO2FBQUssT0FBTyxDQUFDLGtCQUFrQixPQUFPOzs7MERBR2hDLFNBQTJCLFFBQ2pDO2FBQUssY0FBYyxPQUFPO2FBQ3JCLE9BQU8sQ0FBQyxXQUFXLE9BQU87OztzRUFHbkI7WUFDTixPQUFTOztZQUNYLFdBQVcsT0FBTztnQkFDaEIsT0FBTyx5QkFBeUIsS0FBSyxLQUFLLFVBQVU7aUJBQ25ELFNBQVMsTUFBTTtlQUNmLElBQUksaUJBQWlCLE9BQU87Z0JBQzdCLFNBQU8seUJBQXlCLEtBQUssS0FBSyxVQUFVO2lCQUNuRCxlQUFlLFFBQU07Ozs7OztzRUFNaEIsTUFDWjtZQUFJLGdCQUFnQixLQUFLLE9BQU87aUJBQ3pCLGNBQWM7ZUFDZDtpQkFDQSxjQUFjO2lCQUNkLE9BQU8sQ0FBQyxVQUFVLEtBQUssS0FBSyxNQUFNLEtBQUs7Ozs7d0VBSWpDLE1BQ2I7WUFBSSxLQUFLLE1BQU07aUJBQ1IsSUFBSSxDQUFDOzs4QkFFWSxLQUFLO2dCQUF0QjtnQkFBUzs7Z0JBRVYsS0FBSyxNQUFNO3FCQUNSLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLFNBQVM7bUJBQ2pDO3FCQUNBLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxRQUFROzs7OztzRUFLM0IsUUFDWjthQUFLLE9BQU8sQ0FBQyxXQUFXLE9BQU8sUUFBUTs7O3dFQUcxQixRQUNiO2FBQUssT0FBTyxDQUFDLFdBQVcsT0FBTyxRQUFROzs7c0VBRzNCLFFBQ1o7YUFBSyxPQUFPLENBQUMsV0FBVyxPQUFPLFFBQVE7OztrRUFHN0IsUUFDVjthQUFLLE9BQU8sQ0FBQyxXQUFXLE9BQU8sUUFBUTs7OzRFQUd4QixRQUNmO2FBQUssT0FBTyxDQUFDLFdBQVcsT0FBTyxRQUFROzs7Ozt3REFLWjtZQUFXLDZFQUErQjs7O1lBRWpFLEtBQUssZUFBZSxRQUFRO29CQUNkLEtBQUssS0FBSyxLQUFLOzthQUc1QixRQUFRLEtBQUs7OztzRUFHTjsyQkFDTyxLQUFLLE1BQU0sS0FBSyxLQUFLO1lBRWxDO1lBQVEsT0FBUzs7YUFFbEIsWUFBWTthQUNaLGNBQWM7OztzRUFHUCxRQUNaO1lBQUksQ0FBQyxPQUFPLFFBQVE7aUJBQ2IsT0FBTyxDQUFDLFdBQVcsT0FBTzs7O2FBSTVCLElBQUksSUFBSSxPQUFPLFNBQVMsR0FBRyxLQUFLLEdBQUcsS0FDdEM7Z0JBQUksUUFBUSxPQUQrQjtpQkFJckMsTUFBTSxNQUFjOzthQUd2QixPQUFPLENBQUMsZ0JBQWdCLE9BQU8sU0FBUzs7O2tFQUduQyxNQUNWO1lBQUksUUFBUSxLQUFLO1lBRWIsQ0FBQyxNQUFNLFFBQVE7aUJBQ1osT0FBTyxDQUFDLFdBQVcsT0FBTzs7O2FBSTVCLElBQUksSUFBSSxNQUFNLFNBQVMsR0FBRyxLQUFLLEdBQUc7MkJBQ2hCLE1BRHFCO2dCQUNwQztnQkFBSzs7aUJBR0wsTUFBTSxNQUFjO2lCQUNyQixPQUFPLENBQUMsV0FBVyxNQUFNOzthQUczQixPQUFPLENBQUMsaUJBQWlCLE1BQU0sU0FBUzs7O3NGQUd6QixPQUNwQjs7Z0JBRVEsTUFBTTtpQkFDUDtxQkFDRSxPQUFPLENBQUMsV0FBVyxNQUFNLFFBQVE7dUJBQy9CO2lCQUNKO3FCQUNFLGtCQUFrQixDQUFDO3VCQUNqQjtpQkFDSjtxQkFDRSxtQkFBbUIsTUFBTTtxQkFDekIsT0FBTyxDQUFDLFVBQVUsT0FBTzt1QkFDdkI7Ozs7Z0ZBSU0sT0FDakI7YUFBSyxJQUFJLElBQUksTUFBTSxTQUFTLEdBQUcsS0FBSyxHQUFHLEtBQUs7Z0JBQ3RDLE9BQU8sTUFBTTtnQkFFYixLQUFLLFNBQVMscUJBQXFCO3FCQUNoQyxrQkFBa0IsQ0FBQzttQkFDbkIsSUFBSSxLQUFLLFNBQVMsWUFBWTtxQkFDOUIsT0FBTyxDQUFDLFdBQVcsS0FBSyxRQUFROzs7YUFJcEMsT0FBTyxDQUFDLGdCQUFnQixNQUFNLFNBQVM7OzsrQkFHNUI7WUFBQzs7YUFDWixtQkFBbUI7OztvREFHckI7WUFDQyxNQUFNLEtBQUs7WUFDWCxDQUFDLEtBQUs7bUJBQ0Q7O1lBR0g7WUFBUTtZQUFPLE1BQVE7O2VBQ3RCLENBQUMsT0FBTyxDQUFDLFVBQVUsTUFBTSxDQUFDLE1BQU0sTUFBTSxNQUFNLFNBQVMsQ0FBQyxJQUFJLE1BQU0sSUFBSTs7Ozs7O0FBSS9FLDRCQUNFLFVBRUE7V0FDRyxTQUFTLFVBQVUsU0FBUyxPQUFPLFNBQXBDLEtBQ0MsU0FBUyxRQUFRLFNBQVMsS0FBSyxNQUFNLFNBQVM7O0FBSW5ELFNBQXNCO1FBQUU7O1dBQ2YsTUFBTSxXQUFXOztBQUcxQixpQkFBaUIsTUFDZjtXQUFPLEtBQUssYUFBYTs7QUFHM0IsbUJBQW1CLE1BQ2pCO1dBQU8sS0FBSyxhQUFhOztBQUczQixvQkFBb0IsTUFDbEI7V0FBTyxLQUFLLGFBQWE7O0FBRzNCLG9CQUFvQixNQUNsQjtXQUFPLEtBQUssYUFBYTs7QUFHM0IsMEJBQTBCLE1BQ3hCO1dBQU8sS0FBSyxhQUFhOztBQUczQix5QkFBeUIsTUFDdkI7V0FBTyxXQUFXLFNBQVMsaUJBQWlCOztBQUc5QyxlQUFlLE1BQ2I7V0FBTyxDQUFDLENBQUMsS0FBSzs7QUFHaEIsNEJBQTRCO1FBQ3RCLE9BQU8sUUFBUSxJQUFJLE9BQU87OzZCQUVYLFFBQVEsSUFBSSxNQUFNO1FBQWhDOztRQUNELGtCQUFrQixTQUFTO1FBQzNCLFVBQVUsUUFBUSxXQUFXLElBQUk7UUFDakMsYUFBYSxRQUFRLElBQUksUUFBUSxhQUFhO1dBRTNDLFdBQVcsbUJBQW1COztBQUd2QyxxQkFBcUIsU0FDbkI7UUFBSSxPQUFPLFFBQVEsSUFBSSxPQUFPO1FBQzFCLFNBQVMsUUFBUSxJQUFJLFFBQVEsT0FBTyxDQUFDO1FBRXJDLGNBQWMsU0FBUyxLQUFLLGlCQUFpQixTQUFTLEtBQUs7V0FFdkQsZUFBZSxDQUFoQixVQUE0QixtQkFBbUI7O0FBR3hELDRCQUE0QixNQUEwQixLQUF5QixTQUM3RTtRQUFJLENBQUMsYUFBYSxPQUFPO2NBQ2pCLElBQUlDLHlCQUNILEtBQUssNENBQXdDLHdCQUFtQixJQUFJLE1BQU0sWUFDL0UsS0FBSzs7O0FBS1gsMEJBQTBCO1FBQ2xCLFFBQVUsVUFBVTs7UUFFckIsTUFBTSxXQUFXLEtBQUssTUFBTSxHQUFHLFFBQWhDLFFBQWlELE1BQU0sU0FBUyxHQUFHO2NBQy9ELElBQUlBLHVFQUE4RCxVQUFVO2VBQ3pFLE1BQU0sV0FBVyxLQUFLLE1BQU0sR0FBRyxNQUFNLFNBQVMsaUJBQWlCO2NBQ2xFLElBQUlBLDREQUFxRCxVQUFVO2VBQ2hFLE1BQU0sV0FBVyxHQUFHO2VBQ3RCO1dBQ0Y7ZUFDRyxNQUFNLEdBQUcsTUFBNEI7OztBQUlqRCw0QkFBNEI7UUFDcEI7UUFBUTtRQUFNO1FBQVMsTUFBUTs7UUFFakMsVUFBVSxPQUFPLFdBQVcsR0FBRztjQUMzQixJQUFJQSxvR0FFTixJQUFJLE1BQU0sWUFFWixVQUFVO2VBRUgsUUFBUSxLQUFLLE1BQU0sU0FBUyxHQUFHO2NBQ2xDLElBQUlBLDJFQUM4QyxJQUFJLE1BQU0sWUFDaEUsVUFBVTtXQUVQLElBQUksQ0FBQyxTQUFTO2NBQ2IsSUFBSUEsd0dBRU4sSUFBSSxNQUFNLFlBRVosVUFBVTs7V0FJUDs7QUFHVCxrQ0FBa0MsTUFBYztRQUN4QztRQUFRO1FBQU0sTUFBUTs7UUFFeEIsUUFBUSxLQUFLLE1BQU0sU0FBUyxHQUFHO2NBQzNCLElBQUlBLG1CQUFlLDZDQUEwQyxLQUFLOztRQUd0RSxPQUFPLFdBQVcsR0FBRztlQUNoQjtlQUNFLE9BQU8sV0FBVyxHQUFHO1lBQzFCLFFBQVEsT0FBTztZQUNmLE1BQU0sU0FBUyxpQkFBaUI7bUJBQzNCLE1BQU07ZUFDUjtrQkFDQyxJQUFJQSx1RUFDMEMsSUFBSSxNQUFNLFlBQzVELEtBQUs7O1dBR0o7Y0FDQyxJQUFJQSxtQkFDTCw4REFBeUQsSUFBSSxNQUFNLFlBQ3RFLEtBQUs7OztBQUtYLGtDQUFrQztRQUMxQjtRQUFRLE9BQVM7O1FBRW5CLFFBQVEsS0FBSyxNQUFNLFNBQVMsR0FBRztjQUMzQixJQUFJQSxpRUFBMEQsVUFBVTs7UUFHNUUsT0FBTyxXQUFXLEdBQUc7ZUFDaEI7V0FDRjtjQUNDLElBQUlBLHNFQUErRCxVQUFVOzs7O0lDeGlCMUUsWUFBMkIsWUFDdEM7UUFBSSxPQUFPLFlBQVksWUFBWTtZQUM3Qjs7Z0JBRUksU0FBUyxRQUFROztnQkFHbkIsT0FBcUIsbUJBQ3ZCO29CQUFJLE9BQU8sT0FBTyxXQUFXO3FCQUN4QixPQUFPLEtBQUs7O3VCQUVWLEtBQUssT0FBTyxVQUFVLFVBQVUsR0FBRzs7aUJBR3ZDO21CQUVFO1VBQ1AsT0FBTyxHQUFHOztXQUdQLGdCQUNMO2VBQU87OztBQUlYLElBQU07UUFDQTtVQURvQzs7QUFvQjFDLG9CQUNFO1FBQ0EsOEVBQTZCOztRQUV6QixNQUFNQyxrQkFBVyxRQUFRO1FBQ3ZCLE9BQVM7O2dDQUNDLGlCQUFpQixRQUFRLEtBQUs7UUFBeEM7O1FBQ0YsT0FBTyxRQUFRLE1BQU07UUFDckIsWUFBWSxLQUFLLFVBQVUsTUFBTTtRQUNqQztZQUNFLEtBQUssS0FBSyxVQUFVLFFBQVE7ZUFDekI7Y0FGK0Q7OztXQU9qRSxLQUFLLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7In0=