<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/-private/system/relationships/state/has-many.js - The ember-data API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="The ember-data API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v3.4.3</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/DS.html">DS</a></li>
                                <li><a href="../classes/DS.AbortError.html">DS.AbortError</a></li>
                                <li><a href="../classes/DS.Adapter.html">DS.Adapter</a></li>
                                <li><a href="../classes/DS.AdapterError.html">DS.AdapterError</a></li>
                                <li><a href="../classes/DS.AdapterPopulatedRecordArray.html">DS.AdapterPopulatedRecordArray</a></li>
                                <li><a href="../classes/DS.BelongsToReference.html">DS.BelongsToReference</a></li>
                                <li><a href="../classes/DS.BooleanTransform.html">DS.BooleanTransform</a></li>
                                <li><a href="../classes/DS.BuildURLMixin.html">DS.BuildURLMixin</a></li>
                                <li><a href="../classes/DS.ConflictError.html">DS.ConflictError</a></li>
                                <li><a href="../classes/DS.DateTransform.html">DS.DateTransform</a></li>
                                <li><a href="../classes/DS.EmbeddedRecordsMixin.html">DS.EmbeddedRecordsMixin</a></li>
                                <li><a href="../classes/DS.Ember.HTMLBars.helpers.html">DS.Ember.HTMLBars.helpers</a></li>
                                <li><a href="../classes/DS.Errors.html">DS.Errors</a></li>
                                <li><a href="../classes/DS.ForbiddenError.html">DS.ForbiddenError</a></li>
                                <li><a href="../classes/DS.HasManyReference.html">DS.HasManyReference</a></li>
                                <li><a href="../classes/DS.InvalidError.html">DS.InvalidError</a></li>
                                <li><a href="../classes/DS.JSONAPIAdapter.html">DS.JSONAPIAdapter</a></li>
                                <li><a href="../classes/DS.JSONAPISerializer.html">DS.JSONAPISerializer</a></li>
                                <li><a href="../classes/DS.JSONSerializer.html">DS.JSONSerializer</a></li>
                                <li><a href="../classes/DS.ManyArray.html">DS.ManyArray</a></li>
                                <li><a href="../classes/DS.Model.html">DS.Model</a></li>
                                <li><a href="../classes/DS.NotFoundError.html">DS.NotFoundError</a></li>
                                <li><a href="../classes/DS.NumberTransform.html">DS.NumberTransform</a></li>
                                <li><a href="../classes/DS.PromiseArray.html">DS.PromiseArray</a></li>
                                <li><a href="../classes/DS.PromiseManyArray.html">DS.PromiseManyArray</a></li>
                                <li><a href="../classes/DS.PromiseObject.html">DS.PromiseObject</a></li>
                                <li><a href="../classes/DS.RecordArray.html">DS.RecordArray</a></li>
                                <li><a href="../classes/DS.RecordArrayManager.html">DS.RecordArrayManager</a></li>
                                <li><a href="../classes/DS.RecordReference.html">DS.RecordReference</a></li>
                                <li><a href="../classes/DS.RESTAdapter.html">DS.RESTAdapter</a></li>
                                <li><a href="../classes/DS.RESTSerializer.html">DS.RESTSerializer</a></li>
                                <li><a href="../classes/DS.RootState.html">DS.RootState</a></li>
                                <li><a href="../classes/DS.Serializer.html">DS.Serializer</a></li>
                                <li><a href="../classes/DS.ServerError.html">DS.ServerError</a></li>
                                <li><a href="../classes/DS.Snapshot.html">DS.Snapshot</a></li>
                                <li><a href="../classes/DS.SnapshotRecordArray.html">DS.SnapshotRecordArray</a></li>
                                <li><a href="../classes/DS.Store.html">DS.Store</a></li>
                                <li><a href="../classes/DS.String.html">DS.String</a></li>
                                <li><a href="../classes/DS.StringTransform.html">DS.StringTransform</a></li>
                                <li><a href="../classes/DS.TimeoutError.html">DS.TimeoutError</a></li>
                                <li><a href="../classes/DS.Transform.html">DS.Transform</a></li>
                                <li><a href="../classes/DS.UnauthorizedError.html">DS.UnauthorizedError</a></li>
                                <li><a href="../classes/Ember.HTMLBars.helpers.html">Ember.HTMLBars.helpers</a></li>
                                <li><a href="../classes/Ember.Inflector.html">Ember.Inflector</a></li>
                                <li><a href="../classes/IdentityMap.html">IdentityMap</a></li>
                                <li><a href="../classes/InternalModelMap.html">InternalModelMap</a></li>
                                <li><a href="../classes/RelationshipPayloads.html">RelationshipPayloads</a></li>
                                <li><a href="../classes/RelationshipPayloadsManager.html">RelationshipPayloadsManager</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ember-data.html">ember-data</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: addon/-private/system/relationships/state/has-many.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { assert } from &#x27;@ember/debug&#x27;;
import { assertPolymorphicType } from &#x27;ember-data/-debug&#x27;;
import { PromiseManyArray } from &#x27;../../promise-proxies&#x27;;
import Relationship from &#x27;./relationship&#x27;;
import OrderedSet from &#x27;../../ordered-set&#x27;;
import ManyArray from &#x27;../../many-array&#x27;;
import { resolve } from &#x27;rsvp&#x27;;

export default class ManyRelationship extends Relationship {
  constructor(store, internalModel, inverseKey, relationshipMeta) {
    super(store, internalModel, inverseKey, relationshipMeta);
    this.belongsToType = relationshipMeta.type;
    this.canonicalState = [];
    // The ManyArray for this relationship
    this._manyArray = null;
    // The previous ManyArray for this relationship.  It will be destroyed when
    // we create a new many array, but in the interim it will be updated if
    // inverse internal models are unloaded.
    this._retainedManyArray = null;
    this._promiseProxy = null;
    this._willUpdateManyArray = false;
    this._pendingManyArrayUpdates = null;
  }

  get currentState() {
    return this.members.list;
  }

  /**
   * Flag indicating whether all inverse records are available
   *
   * true if inverse records exist and are all loaded (all not empty)
   * true if there are no inverse records
   * false if the inverse records exist and any are not loaded (any empty)
   *
   * @property
   * @return {boolean}
   */
  get allInverseRecordsAreLoaded() {
    // check currentState for unloaded records
    let hasEmptyRecords = this.currentState.reduce((hasEmptyModel, i) =&gt; {
      return hasEmptyModel || i.isEmpty();
    }, false);

    // check un-synced state for unloaded records
    if (!hasEmptyRecords &amp;&amp; this.willSync) {
      hasEmptyRecords = this.canonicalState.reduce((hasEmptyModel, i) =&gt; {
        return hasEmptyModel || !i.isEmpty();
      }, false);
    }

    return !hasEmptyRecords;
  }

  _createProxy(promise, content) {
    return PromiseManyArray.create({
      promise,
      content,
    });
  }

  get manyArray() {
    assert(
      &#x60;Error: relationship ${this.parentType}:${
        this.key
      } has both many array and retained many array&#x60;,
      this._manyArray === null || this._retainedManyArray === null
    );

    if (!this._manyArray &amp;&amp; !this.isDestroying) {
      let isLoaded = this.hasFailedLoadAttempt || this.isNew || this.allInverseRecordsAreLoaded;

      this._manyArray = ManyArray.create({
        canonicalState: this.canonicalState,
        store: this.store,
        relationship: this,
        type: this.store.modelFor(this.belongsToType),
        record: this.internalModel,
        meta: this.meta,
        isPolymorphic: this.isPolymorphic,
        isLoaded,
      });

      if (this._retainedManyArray !== null) {
        this._retainedManyArray.destroy();
        this._retainedManyArray = null;
      }
    }

    return this._manyArray;
  }

  removeInverseRelationships() {
    super.removeInverseRelationships();
    if (this._manyArray) {
      this._manyArray.destroy();
      this._manyArray = null;
    }

    if (this._promiseProxy) {
      this._promiseProxy.destroy();
    }
  }

  updateMeta(meta) {
    super.updateMeta(meta);
    if (this._manyArray) {
      this._manyArray.set(&#x27;meta&#x27;, meta);
    }
  }

  addCanonicalInternalModel(internalModel, idx) {
    if (this.canonicalMembers.has(internalModel)) {
      return;
    }
    if (idx !== undefined) {
      this.canonicalState.splice(idx, 0, internalModel);
    } else {
      this.canonicalState.push(internalModel);
    }
    super.addCanonicalInternalModel(internalModel, idx);
  }

  inverseDidDematerialize(inverseInternalModel) {
    super.inverseDidDematerialize(inverseInternalModel);
    if (this.isAsync) {
      if (this._manyArray) {
        this._retainedManyArray = this._manyArray;
        this._manyArray = null;
      }
      this._removeInternalModelFromManyArray(this._retainedManyArray, inverseInternalModel);
    }
    this.notifyHasManyChange();
  }

  addInternalModel(internalModel, idx) {
    if (this.members.has(internalModel)) {
      return;
    }

    assertPolymorphicType(this.internalModel, this.relationshipMeta, internalModel, this.store);
    super.addInternalModel(internalModel, idx);
    this.scheduleManyArrayUpdate(internalModel, idx);
  }

  scheduleManyArrayUpdate(internalModel, idx) {
    if (!this._manyArray) {
      return;
    }

    let pending = (this._pendingManyArrayUpdates = this._pendingManyArrayUpdates || []);
    pending.push(internalModel, idx);

    if (this._willUpdateManyArray === true) {
      return;
    }

    this._willUpdateManyArray = true;
    let backburner = this.store._backburner;

    backburner.join(() =&gt; {
      backburner.schedule(&#x27;syncRelationships&#x27;, this, this._flushPendingManyArrayUpdates);
    });
  }

  _flushPendingManyArrayUpdates() {
    if (this._willUpdateManyArray === false) {
      return;
    }

    let pending = this._pendingManyArrayUpdates;
    this._pendingManyArrayUpdates = [];
    this._willUpdateManyArray = false;

    for (let i = 0; i &lt; pending.length; i += 2) {
      let internalModel = pending[i];
      let idx = pending[i + 1];

      this.manyArray._addInternalModels([internalModel], idx);
    }
  }

  removeCanonicalInternalModelFromOwn(internalModel, idx) {
    let i = idx;
    if (!this.canonicalMembers.has(internalModel)) {
      return;
    }
    if (i === undefined) {
      i = this.canonicalState.indexOf(internalModel);
    }
    if (i &gt; -1) {
      this.canonicalState.splice(i, 1);
    }
    super.removeCanonicalInternalModelFromOwn(internalModel, idx);
  }

  removeAllCanonicalInternalModelsFromOwn() {
    this.canonicalMembers.clear();
    this.canonicalState.splice(0, this.canonicalState.length);
    super.removeAllCanonicalInternalModelsFromOwn();
  }

  removeCompletelyFromOwn(internalModel) {
    super.removeCompletelyFromOwn(internalModel);

    const canonicalIndex = this.canonicalState.indexOf(internalModel);

    if (canonicalIndex !== -1) {
      this.canonicalState.splice(canonicalIndex, 1);
    }

    const manyArray = this._manyArray;

    if (manyArray) {
      const idx = manyArray.currentState.indexOf(internalModel);

      if (idx !== -1) {
        manyArray.internalReplace(idx, 1);
      }
    }
  }

  flushCanonical() {
    super.flushCanonical();
    if (this._manyArray) {
      this._manyArray.flushCanonical();
    }
  }

  removeInternalModelFromOwn(internalModel, idx) {
    if (!this.members.has(internalModel)) {
      return;
    }
    super.removeInternalModelFromOwn(internalModel, idx);
    // note that ensuring the many array is created, via &#x60;this.manyArray&#x60;
    // (instead of &#x60;this._manyArray&#x60;) is intentional.
    //
    // Because we&#x27;re removing from local, and not canonical, state, it is
    // important that the many array is initialized now with those changes,
    // otherwise it will be initialized with canonical state and we&#x27;ll have
    // lost the fact that this internalModel was removed.
    this._removeInternalModelFromManyArray(this.manyArray, internalModel, idx);
    this._removeInternalModelFromManyArray(this._retainedManyArray, internalModel, idx);
  }

  removeAllInternalModelsFromOwn() {
    super.removeAllInternalModelsFromOwn();
    // as with removeInternalModelFromOwn, we make sure the many array is
    // instantiated, or we&#x27;ll lose local removals, as we&#x27;re not updating
    // canonical state here.
    this.manyArray.clear();
    if (this._retainedManyArray) {
      this._retainedManyArray.clear();
    }
  }

  _removeInternalModelFromManyArray(manyArray, internalModel, idx) {
    if (manyArray === null) {
      return;
    }

    if (idx !== undefined) {
      //TODO(Igor) not used currently, fix
      manyArray.currentState.removeAt(idx);
    } else {
      manyArray._removeInternalModels([internalModel]);
    }
  }

  notifyRecordRelationshipAdded(internalModel, idx) {
    this.internalModel.notifyHasManyAdded(this.key, internalModel, idx);
  }

  computeChanges(internalModels = []) {
    let members = this.canonicalMembers;
    let internalModelsToRemove = [];
    let internalModelSet = setForArray(internalModels);

    members.forEach(member =&gt; {
      if (internalModelSet.has(member)) {
        return;
      }

      internalModelsToRemove.push(member);
    });

    this.removeCanonicalInternalModels(internalModelsToRemove);

    for (let i = 0, l = internalModels.length; i &lt; l; i++) {
      let internalModel = internalModels[i];
      this.removeCanonicalInternalModel(internalModel);
      this.addCanonicalInternalModel(internalModel, i);
    }
  }

  setInitialInternalModels(internalModels) {
    if (Array.isArray(internalModels) === false || internalModels.length === 0) {
      return;
    }

    for (let i = 0; i &lt; internalModels.length; i++) {
      let internalModel = internalModels[i];
      if (this.canonicalMembers.has(internalModel)) {
        continue;
      }

      this.canonicalMembers.add(internalModel);
      this.members.add(internalModel);
      this.setupInverseRelationship(internalModel);
    }

    this.canonicalState = this.canonicalMembers.toArray();
  }

  // called by &#x60;getData()&#x60; when a request is needed
  //   but no link is available
  _fetchRecords(options) {
    let internalModels = this.currentState;
    let { shouldForceReload } = this;
    let promise;

    if (shouldForceReload === true) {
      promise = this.store._scheduleFetchMany(internalModels, options);
    } else {
      promise = this.store.findMany(internalModels, options);
    }

    return promise;
  }

  // called by &#x60;getData()&#x60; when a request is needed
  //   and a link is available
  _fetchLink(options) {
    return this.store
      .findHasMany(this.internalModel, this.link, this.relationshipMeta, options)
      .then(records =&gt; {
        if (records.hasOwnProperty(&#x27;meta&#x27;)) {
          this.updateMeta(records.meta);
        }
        this.store._backburner.join(() =&gt; {
          this.updateInternalModelsFromAdapter(records);
        });
        return records;
      });
  }

  getData(options, isForcedReload = false) {
    //TODO(Igor) sync server here, once our syncing is not stupid
    let manyArray = this.manyArray;

    if (this.shouldMakeRequest()) {
      let promise;

      if (this.link) {
        promise = this._fetchLink(options);
      } else {
        promise = this._fetchRecords(options);
      }

      promise = promise.then(
        () =&gt; handleCompletedRequest(this),
        e =&gt; handleCompletedRequest(this, e)
      );

      this.fetchPromise = promise;
      this._updateLoadingPromise(promise, manyArray);
    }

    if (this.isAsync) {
      if (this._promiseProxy === null) {
        this._updateLoadingPromise(resolve(manyArray), manyArray);
      }

      return this._promiseProxy;
    } else {
      assert(
        &#x60;You looked up the &#x27;${this.key}&#x27; relationship on a &#x27;${
          this.internalModel.type.modelName
        }&#x27; with id ${
          this.internalModel.id
        } but some of the associated records were not loaded. Either make sure they are all loaded together with the parent record, or specify that the relationship is async (\&#x60;DS.hasMany({ async: true })\&#x60;)&#x60;,
        this.allInverseRecordsAreLoaded || isForcedReload
      );

      return manyArray;
    }
  }

  notifyHasManyChange() {
    this.internalModel.notifyHasManyAdded(this.key);
  }

  updateData(data, initial) {
    let internalModels = this.store._pushResourceIdentifiers(this, data);
    if (initial) {
      this.setInitialInternalModels(internalModels);
    } else {
      this.updateInternalModelsFromAdapter(internalModels);
    }
  }

  destroy() {
    this.isDestroying = true;
    super.destroy();
    let manyArray = this._manyArray;
    if (manyArray) {
      manyArray.destroy();
      this._manyArray = null;
    }

    let proxy = this._promiseProxy;

    if (proxy) {
      proxy.destroy();
      this._promiseProxy = null;
    }
    this.isDestroyed = true;
  }
}

function handleCompletedRequest(relationship, error) {
  let manyArray = relationship.manyArray;

  //Goes away after the manyArray refactor
  if (!manyArray.get(&#x27;isDestroyed&#x27;)) {
    relationship.manyArray.set(&#x27;isLoaded&#x27;, true);
  }

  relationship.fetchPromise = null;
  relationship.setShouldForceReload(false);

  if (error) {
    relationship.setHasFailedLoadAttempt(true);
    throw error;
  }

  relationship.setHasFailedLoadAttempt(false);
  // only set to not stale if no error is thrown
  relationship.setRelationshipIsStale(false);

  return manyArray;
}

function setForArray(array) {
  var set = new OrderedSet();

  if (array) {
    for (var i = 0, l = array.length; i &lt; l; i++) {
      set.add(array[i]);
    }
  }

  return set;
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
